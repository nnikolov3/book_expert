#!/bin/bash
# ================================================================================================
# SIMPLIFIED TEXT TO PARAGRAPH CHUNKS PROCESSOR
# Design: Niko Nikolov
# Code: Various LLMs
#
# ## Overview
# This script performs a crucial task in the pipeline: it takes multiple polished text files
# (polished_1.txt, polished_2.txt, etc.) generated by `png_to_page_text.sh` for each PDF,
# concatenates them in memory, and splits the combined text into paragraph-based chunks.
# These chunks are ideal for feeding into a Text-to-Speech (TTS) engine in the next stage.
#
# ## Architecture
# 1. **Discovery**: Scans the output directory for all `polished_*.txt` files in
#    `{output_dir}/{pdf_name}/polished/`, processing each PDFâ€™s files as a group.
# 2. **Input**: Reads and concatenates in memory all polished text files for a given PDF from:
#    `{output_dir}/{pdf_name}/polished/polished_*.txt`.
# 3. **Processing**: Splits the concatenated content based on double newlines (`\n\n`),
#    which are the standard delimiter for paragraphs. Cleans up leading/trailing whitespace.
# 4. **Output**: Saves each paragraph as a separate, sequentially numbered text file in:
#    `{output_dir}/{pdf_name}/tts_chunks/chunk_0001.txt`, `chunk_0002.txt`, etc.
#
# ## Error Handling
# - **Strict Mode**: Uses `set -euo pipefail` to exit immediately if any command fails.
# - **File Validation**: Checks for configuration file, output directory, and input polished
#   text files before processing.
# - **Logging**: Captures all informational messages and errors in a timestamped log file.
#
# ================================================================================================

# Enable strict error handling
set -euo pipefail

# ================================================================================================
# CONFIGURATION AND GLOBAL VARIABLES
# ================================================================================================
declare -r CONFIG_FILE="project.toml"
declare LOG_FILE

# Global variables loaded from config
declare PROJECT_NAME OUTPUT_DIR POLISHED_DIR_NAME TTS_CHUNKS_DIR_NAME

# ================================================================================================
# UTILITY FUNCTIONS
# ================================================================================================

# ## get_config()
# ## Purpose
# Loads configuration from `project.toml`.
# ## Parameters
# - $1: Configuration key to retrieve.
# ## Returns
# - The value of the key, or exits with error if missing.
get_config()
{
	local key="$1"
	local value
	value=$(yq -r ".${key} // \"\"" "$CONFIG_FILE" 2>/dev/null)
	if [[ -z $value ]]; then
		log_error "Missing required configuration key '$key' in $CONFIG_FILE"
		exit 1
	fi
	echo "$value"
}

# ## log_info(), log_error()
# ## Purpose
# Logs messages with timestamps to stdout/stderr and LOG_FILE.
# ## Parameters
# - $*: Message to log.
log_info()
{
	echo "[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $*" | tee -a "$LOG_FILE"
}

log_error()
{
	echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
	echo "[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $*" >>"$LOG_FILE"
}

# ================================================================================================
# MAIN PROCESSING FUNCTION
# ================================================================================================

# ## process_pdf_directory()
# ## Purpose
# Processes all polished text files for a single PDF, concatenating them in memory and creating
# paragraph chunks.
# ## Parameters
# - $1: The directory containing polished text files (`{output_dir}/{pdf_name}/polished`).
# ## Returns
# - 0 on success, 1 on failure.
process_pdf_directory()
{
	local polished_dir="$1"

	# Extract PDF name from the directory path
	local pdf_name
	pdf_name=$(basename "$(dirname "$polished_dir")")

	# Set up output directory for chunks
	local chunks_dir="$OUTPUT_DIR/$pdf_name/$TTS_CHUNKS_DIR_NAME"

	log_info "Processing PDF: $pdf_name"
	log_info "Input directory: $polished_dir"
	log_info "Output directory: $chunks_dir"

	# Create chunks directory
	if ! mkdir -p "$chunks_dir"; then
		log_error "Failed to create chunks directory: $chunks_dir"
		return 1
	fi

	# Find all polished text files
	local -a polished_files
	mapfile -d '' -t polished_files < <(find "$polished_dir" -type f -name "polished_*.txt" -print0 | sort -z)

	if [[ ${#polished_files[@]} -eq 0 ]]; then
		log_error "No polished text files found in: $polished_dir"
		return 1
	fi

	log_info "Found ${#polished_files[@]} polished text file(s) for PDF: $pdf_name"

	# Concatenate all polished files in memory
	local content=""
	local file
	for file in "${polished_files[@]}"; do
		local file_content
		if ! file_content=$(<"$file"); then
			log_error "Failed to read file: $file"
			return 1
		fi
		# Append content with a double newline to ensure paragraph separation
		content+="$file_content"$'\n\n'
	done

	# Skip if concatenated content is empty
	if [[ -z $content ]]; then
		log_info "Skipping empty concatenated content for PDF: $pdf_name"
		return 0
	fi

	# Split content into paragraphs using double newlines as delimiter
	local chunk_num=1
	local paragraph
	# Use a process substitution and while-read loop for robust newline handling
	while IFS= read -r -d '' paragraph; do
		# Clean up leading/trailing whitespace
		paragraph=$(echo "$paragraph" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

		# Skip empty paragraphs
		if [[ -z $paragraph ]]; then
			continue
		fi

		# Create chunk filename with zero-padded number
		local chunk_file="$chunks_dir/chunk_$(printf "%04d" "$chunk_num").txt"

		# Save paragraph to chunk file
		if ! printf "%s" "$paragraph" >"$chunk_file"; then
			log_error "Failed to create chunk file: $chunk_file"
			return 1
		fi

		log_info "Created chunk $chunk_num: $(wc -c <"$chunk_file") bytes"
		((chunk_num++))

	done < <(printf '%s\0' "$content" | awk -v RS='\n\n' -v ORS='\0' '{print}')

	local total_chunks=$((chunk_num - 1))
	log_info "Successfully created $total_chunks chunks for PDF: $pdf_name"
	return 0
}

# ================================================================================================
# MAIN EXECUTION
# ================================================================================================
main()
{
	if [[ ! -f $CONFIG_FILE ]]; then
		log_error "Configuration file not found: $CONFIG_FILE"
		exit 1
	fi

	# Load configuration
	PROJECT_NAME=$(get_config "project.name")
	OUTPUT_DIR=$(get_config "paths.output_dir")
	POLISHED_DIR_NAME=$(get_config "directories.polished_dir")
	TTS_CHUNKS_DIR_NAME=$(get_config "directories.tts_chunks")

	# Setup logging
	local LOG_DIR
	LOG_DIR=$(get_config "logs_dir.text_to_chunks")
	mkdir -p "$LOG_DIR"
	LOG_FILE="$LOG_DIR/text_chunks_$(date +'%Y%m%d_%H%M%S').log"
	touch "$LOG_FILE"

	log_info "Starting text to paragraph chunks conversion."
	log_info "Project: $PROJECT_NAME"
	log_info "Output directory: $OUTPUT_DIR"

	# Check if output directory exists
	if [[ ! -d $OUTPUT_DIR ]]; then
		log_error "Output directory not found: $OUTPUT_DIR"
		exit 1
	fi

	# Find all polished directories
	local find_path_pattern="*/$POLISHED_DIR_NAME"
	log_info "Searching for polished directories with pattern: $OUTPUT_DIR/$find_path_pattern"

	local -a polished_dirs
	mapfile -d '' -t polished_dirs < <(find "$OUTPUT_DIR" -type d -path "$OUTPUT_DIR/$find_path_pattern" -print0 | sort -z)

	if [[ ${#polished_dirs[@]} -eq 0 ]]; then
		log_error "No polished directories found with pattern: $OUTPUT_DIR/$find_path_pattern"
		exit 1
	fi

	log_info "Found ${#polished_dirs[@]} polished director(y/ies) to process."

	# Process each PDF directory
	local processed=0
	local failed=0
	for polished_dir in "${polished_dirs[@]}"; do
		if process_pdf_directory "$polished_dir"; then
			((processed++))
		else
			((failed++))
			log_error "Failed to process directory: $polished_dir"
		fi
	done

	# Final summary
	log_info "Processing complete."
	log_info "  Successfully processed: $processed director(y/ies)"
	log_info "  Failed to process: $failed director(y/ies)"

	if [[ $failed -gt 0 ]]; then
		log_error "Some directories failed to process. Check the log for details."
		exit 1
	fi

	log_info "All directories processed successfully!"
	exit 0
}

# Run main function
main "$@"
