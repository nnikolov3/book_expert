
In concurrent data structures, the Extensible and Resilient Binary Search Tree, or EFRB tree, introduces a sophisticated mechanism for managing node modifications in a multi-threaded environment. At the heart of this mechanism is the concept of locking a node through its update field, which points to a descriptor. This descriptor contains detailed information about the operation currently holding the lock on the node. By doing so, the EFRB tree enables other threads to assist in completing the operation rather than waiting idly for the node to be unlocked. This cooperative approach enhances the efficiency and scalability of the tree under high concurrency.

A critical principle underlying the EFRB tree's design is idempotency. Idempotency ensures that performing an operation multiple times has the same effect as performing it once. This is particularly important in concurrent environments where a helper thread might attempt to execute a compare-and-swap, or CAS, operation multiple times due to contention for a lock. CAS operations are atomic instructions that perform a read-modify-write sequence, ensuring that each step can succeed only once. This atomicity guarantees that even if multiple threads attempt to assist in the same operation, the outcome remains consistent and predictable.

Each node in the EFRB tree conceptually stores two distinct pieces of information within a single word: the state field and the info field. The state field can take on one of four values—Clean, IFlag, DFlag, or Mark—each indicating the current status of the node. When a node is in the Clean state, it is unlocked and available for modification. If it is in the IFlag or DFlag state, it is locked for an insert or delete operation, respectively. A node in the Mark state is considered locked indefinitely by the operation that deleted it. The info field, on the other hand, points to a descriptor that provides details about the operation currently affecting the node. If the node is not currently locked, the info field points to the descriptor of the last operation that locked it.

A node's child pointers can only be modified while the node is locked for the specific operation that holds the lock. Furthermore, once a node's key is set, it becomes immutable, meaning it cannot be changed without first unlocking the node. This immutability ensures that the structure of the tree remains consistent and that concurrent operations do not inadvertently alter the keys being searched or modified.

The lookup operation in the EFRB tree is designed to be highly efficient and does not require synchronization between threads. It behaves similarly to a lookup in a sequential external binary search tree, performing a binary search starting from the root and continuing until it reaches a leaf. This process is oblivious to the actions of other concurrent threads, allowing for fast and non-blocking lookups. If the leaf contains the key being searched for, the operation returns true; otherwise, it returns false.

The EFRB tree's design is based on the concept of lock-free mutual exclusion, introduced by Barnes. This approach uses compare-and-swap operations instead of traditional locking mechanisms to manage concurrent access to shared data. The use of distinct descriptor types and flagging techniques further refines this approach, enabling efficient and scalable concurrent operations.

The data structure of the EFRB tree includes atomic pointers for the left and right child nodes, as well as an update pointer that facilitates the coordination of concurrent modifications. The tree's operations, including lookup, insert, and delete, are designed to work in a lock-free manner, leveraging CAS operations to ensure atomicity and consistency.

The search function traverses the tree based on key comparisons, returning a tuple containing the grandparent, parent, and parent's update pointer. This information is crucial for subsequent atomic operations that may modify the tree structure. Helper functions, such as help_insert and help_delete, assist in completing ongoing operations, ensuring that the tree remains in a consistent state even in the presence of concurrent modifications.

The use of CAS operations and idempotent helping ensures that the EFRB tree can maintain its integrity and correctness, even under high concurrency. This is achieved through the careful design of the tree's data structure and operations, which prioritize atomicity, consistency, and cooperation among threads. As a result, the EFRB tree offers a highly efficient and scalable solution for concurrent search and update operations, making it an attractive choice for applications that require high performance and reliability in multi-threaded environments.

To understand why the lookup algorithm is linearizable, consider a scenario where a lookup operation finds a leaf containing the key and returns true. If that leaf is in the tree when the lookup operation reads the key, the operation can be linearized at that read. However, if the leaf is deleted by another thread after the lookup has read the key but before the lookup operation completes its linearization, the lookup still returns true, which is consistent with the key having been present at some point. The critical aspect here is the timing of the read relative to the deletion. If the lookup reads the key from a node that is then modified or removed, and the lookup is linearized to the time of the read, this maintains consistency with the state of the data structure at that linearized instant.

In contrast, if a lookup fails to find a key, the situation differs between internal and external binary search trees. In an internal binary search tree, a lookup might miss the key even if it is present throughout the entire lookup operation, because the key could be swapped to a higher location in the tree. However, in an external binary search tree, such key swaps do not occur. If a key is present for part of the lookup operation but is deleted during that operation, the lookup may incorrectly return false if the deletion happens before the lookup reaches the relevant leaf. Alternatively, if the key is present and the lookup completes successfully, but the key is deleted immediately after, the lookup can still be linearized to a point where the key was present.

For an insert operation, a thread first searches for the key's position, similar to a lookup. The thread captures the current value of the parent's update field, referred to as parent update, which serves as the expected value for a compare and swap operation. The insert operation then attempts to lock the parent node by creating a new descriptor and attempting to atomically update the parent's update field to point to this new descriptor using a compare and swap operation. If the compare and swap operation succeeds, the parent has been successfully locked, and the thread proceeds with the insertion. If the operation fails, the thread must restart its operation, as the state of the data structure has changed in a way that invalidates the assumptions made during the initial search.

If the parent is already locked by another operation, the thread attempting to insert may assist the ongoing operation before restarting its own. This assistance ensures that operations can complete even in the face of concurrent modifications. When an insert operation restarts due to a compare and swap failure, the failure implies that the parent's state has changed, and the descriptor that was attempted to be allocated is not incorporated into the data structure's linearization. It can either be freed or potentially reused in a subsequent attempt.

The delete operation begins similarly to the insert operation, searching for the key to determine the target, parent, and grandparent nodes. If the search does not find the key, the delete operation returns false and is linearized as a lookup operation. If the key is found, the thread locks the grandparent and parent nodes and replaces the parent and target with the sibling of the target, effectively removing the parent and target from the tree. If either the grandparent or parent is already locked, the thread helps the ongoing operation before restarting its own.

The delete operation involves creating a new DeleteFlag descriptor and locking the parent node's update field using a compare and swap operation, which atomically changes its state to DFlag. The grandparent node's update field is also locked, and the node is marked for deletion. If the compare and swap operation fails, the deleting thread performs a compare and swap to try to transition the grandparent's update from DFlag to Clean, effectively rolling back or retrying the operation. This handling of compare and swap failures is crucial for the progress and correctness of nonblocking algorithms, ensuring that operations can complete even in the face of concurrent modifications.
