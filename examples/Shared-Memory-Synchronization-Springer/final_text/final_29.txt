
Safe memory reclamation is a critical component in the design of concurrent data structures, where multiple threads access and modify shared memory. The central challenge is ensuring that memory is not deallocated while it is still being accessed by any thread. If a thread accesses memory that has already been freed, it can lead to data corruption, undefined behavior, or crashes. To address this, several memory reclamation techniques have been developed, each with its own trade-offs in terms of performance, complexity, and generality.

One widely used approach is hazard pointers. This method allows individual threads to declare that they are currently accessing a specific node in a data structure. Each thread maintains a set of hazard pointers, which are essentially references to nodes that the thread is actively using. Before a node is reclaimed, the system checks all hazard pointers across all threads. If any thread has marked a node as hazardous, that node is not freed. This ensures that no thread can access a node that has already been deallocated. Hazard pointers are effective but can be somewhat heavy in terms of overhead, especially when many threads are involved, because each thread must manage its own hazard pointer array and the system must scan all of them before reclaiming memory.

Another approach is epoch-based reclamation. This technique relies on the idea that threads periodically enter a quiescent state—meaning they are not actively accessing any nodes in the data structure. During this time, the system can determine that the thread no longer holds any references to nodes that might be candidates for reclamation. The system maintains a global epoch counter, and each thread also tracks its current epoch. When a thread begins an operation on the data structure, it updates its local epoch value to match the current global epoch. This allows the system to track which threads have passed through a quiescent state since a particular node was removed. A node can only be safely reclaimed after all threads that could have accessed it have passed through at least one full epoch cycle. This method is efficient and avoids the need for per-node tracking, but it can suffer from delays when some threads are slow to update their epoch or stop participating altogether.

A specific implementation of epoch-based reclamation is DEBRA, which is optimized for use in the EFRB tree. DEBRA introduces two key functions: startOp and endOp. These functions manage the thread's participation in the current epoch cycle. When a thread begins an operation on the data structure, it calls startOp, which updates its epoch value. When the operation is complete, it calls endOp, which marks the thread as having completed its current operation. This mechanism ensures that the global epoch can be advanced safely once all threads have completed their current operations. DEBRA is known for its high performance and is one of the fastest implementations of epoch-based reclamation. However, it has a limitation: if a thread stops calling endOp, the system cannot advance the epoch, and memory reclamation stalls. This can lead to memory exhaustion if the system continues to allocate new nodes without being able to free old ones.

To address this limitation, DEBRA+ was developed. It introduces a mechanism to handle slow or stalled threads by using POSIX signals. When a thread is taking too long to update its epoch, the system sends it a signal, which triggers a recovery process. The thread executes special recovery code that ensures the data structure remains consistent and allows the system to continue reclaiming memory. This approach maintains lock-free progress and prevents memory leaks even when some threads are not cooperating.

Another technique is Interval-Based Reclamation, or IBR. This method combines elements of both hazard pointers and epoch-based reclamation. In IBR, each node is associated with two epoch values: a birth epoch and a retire epoch. The birth epoch indicates when the node was first added to the data structure, and the retire epoch indicates when it was logically removed. Threads can determine whether a node was active during a particular epoch by comparing these values. This allows the system to track which nodes are safe to reclaim without requiring per-thread hazard pointer arrays or complex synchronization. IBR offers bounded garbage collection and high performance, and it does not require data structure-specific recovery code, making it more general-purpose than some other methods.

Building on IBR is Neutralization-Based Reclamation, or NBR. This technique allows threads to continue executing even if they are neutralized—meaning they are temporarily unable to update their epoch or participate in reclamation. As long as a thread has reserved the nodes it is using, those nodes are protected from reclamation. NBR divides operations into three phases: read, reservation, and write. During the reservation phase, a thread explicitly marks the nodes it intends to use, ensuring that they are not freed while the thread is working. This approach provides strong guarantees about memory safety and allows for efficient reclamation, even in the presence of neutralized threads.

The Free Access algorithm is another approach that applies to arbitrary lock-free data structures. It introduces a mechanism called a dirty bit, which tracks whether a thread has recently read a value from the data structure. If the dirty bit is set, the thread must discard any previously read values and re-read them to ensure consistency. This allows the system to reclaim memory safely without requiring complex coordination between threads. However, the Free Access algorithm can be slower than epoch-based reclamation and requires significant effort from the programmer to implement correctly.

In the context of the EFRB tree, a specific challenge arises with the help delete method. This method allows a thread to assist in the deletion of a node that another thread has marked for removal. However, if a thread attempts to delete a node that it has not yet reserved, it can lead to race conditions or memory corruption. To address this, one solution is to eliminate the help delete call entirely, ensuring that deletions are only performed by the thread that originally initiated them. Alternatively, the data structure can be modified so that all required nodes are visited and reserved before any modifications begin, ensuring that deletions are safe and consistent.

Overall, these memory reclamation techniques aim to provide efficient, safe, and scalable solutions for managing memory in concurrent data structures. Each method has its own strengths and limitations, and the choice of technique depends on the specific requirements of the system. By understanding how these methods work and how they interact with the data structures they support, developers can design nonblocking algorithms that maintain data integrity while maximizing performance and minimizing memory overhead.
