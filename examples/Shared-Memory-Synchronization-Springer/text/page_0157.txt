8.6 Search Trees 161

is “locked,” its update field points to a descriptor that contains information about what
the operation holding the lock 1s trying to do. Whenever a thread encounters a node that is
“locked” in this way, instead of waiting (or blocking) until the node is “unlocked,” the thread
can instead help the operation that holds the “lock™ to finish by performing steps outlined
in the descriptor, after which it can “unlock” the node.” In the EFRB tree, a thread helps
another operation O only if its own operation is blocked by O.

A single operation can potentially have many concurrent helpers. One might wonder why
inconsistencies cannot be caused by helpers performing important steps multiple times, or
out of order. The key ideas for consistent helping are (1) to perform modifications via a
sequence of CAS steps, and (2) to ensure that each CAS step can succeed only once (the first
time it 1s performed). This makes helping idempotent. Similar ideas underlie the steps of the
Michael deque of Sec. 8.3.2.

The update field of an EFRB tree node conceptually stores two separate fields (state, info)
within a single word. The state field can hold one of four possible values—Clean, IFlag,
DFlag or Mark; the info points to a descriptor.’ The Clean state indicates that the node
is “unlocked”. The IFlag and DFlag states indicate that the node is “locked” for an
insert or delete operation, respectively. We think of a node with state Mark as being
“locked” indefinitely by the operation that deleted it (so no other operation can “lock™ it to
modify it).

When a node is currently “locked” by an operation, the info field points to the descriptor
for that operation (an InsertFlag descriptor for insert or a DeleteFlag descriptor for delete).
Otherwise info points to the descriptor for the last operation that “locked” the node. A node
can have its child pointers changed by an operation only while the node 1s “locked” for that
operation, and a “locked” node can be changed only in accordance with the operation that
“locked” it. A node’s key is immutable once set: only its left and right pointers and update
field can change.

Lookup Operation A particularly surprising property of the EFRB tree is that lookup
operations do not need to perform any synchronization between threads. More specifically,
a lookup (key) operation behaves exactly as it would in a sequential external BST. It simply
does a binary search on the tree starting at the root, and continues until it reaches a leaf
(oblivious to the actions of other concurrent threads). If it reaches a leaf containing key,
then it returns true. Otherwise it returns false. Pseudocode appears in Figures 8.14 and 8.15.

2 The idea of “lock-free mutual exclusion” was introduced by Barnes (1993b) in his description of a
“cooperative technique” for lock-free synchronization. One could sensibly view the EFRB tree as a
specialization of Barnes’ approach that uses compare and swap instead of load-link/store-conditional,
and has several distinct descriptor types. More recently, Ben-David et al. (2022) generalized and
further formalized this idea. The specific flagging and marking techniques in the EFRB tree paper
were inspired by earlier work by Fomitchev and Ruppert (2004).

3 Note that if descriptors are word-aligned on a 32-bit architecture, then the two least significant bits
of any descriptor pointer are zero, so these two bits are conceptually free to store the state. On a
64-bit architecture, three bits are free.
Search Trees. Is locked, its update field points to a descriptor that contains information about what operation holding the lock is trying to do. Whenever a thread encounters a node that is locked in this way, instead of waiting or blocking until the node is unlocked, the thread can instead help the operation that holds the lock to finish by performing steps outlined in the descriptor, after which it can unlock the node. In the E F R B tree, a thread helps another operation O only if its own operation is blocked by O. A single operation can potentially have many concurrent helpers. One might wonder why inconsistencies cannot be caused by helpers performing important steps multiple times, or out of order. The key ideas for consistent helping are one to perform modifications via a sequence of C A S steps, and two to ensure that each C A S step can succeed only once the first time it is performed. This makes helping idempotent. Similar ideas underlie the steps of the Michael deque of Section eight point three point two. The update field of an E F R B tree node conceptually stores two separate fields, state and info, within a single word. The state field can hold one of four possible values: Clean, I F F L A G, D F L A G or Mark. The info points to a descriptor. The Clean state indicates that the node is unlocked. The I F F L A G and D F L A G states indicate that the node is locked for an insert or delete operation, respectively. We think of a node with state Mark as being locked indefinitely by the operation that deleted it, so no other operation can lock it to modify it. When a node is currently locked by an operation, the info field points to the descriptor for that operation an insert F L A G descriptor for insert or a D E L E T E F L A G descriptor for delete. Otherwise, info points to the descriptor for the last operation that locked the node. A node can have its child pointers changed by an operation only while the node is locked for that operation, and a locked node can be changed only in accordance with the operation that locked it. A node's key is immutable once set; only its left and right pointers and update field can change. Lookup Operation. A particularly surprising property of the E F R B tree is that lookup operations do not need to perform any synchronization between threads. More specifically, a lookup key operation behaves exactly as it would in a sequential external B S T. It simply does a binary search on the tree starting at the root, and continues until it reaches a leaf oblivious to the actions of other concurrent threads. If it reaches a leaf containing key, then it returns true. Otherwise, it returns false. Pseudocode appears in Figures eight point fourteen and eight point fifteen. The idea of lock free mutual exclusion was introduced by Barnes, in his description of a cooperative technique for lock free synchronization. One could sensibly view the E F R B tree as a specialization of Barnes approach that uses compare and swap instead of load link store conditional, and has several distinct descriptor types. More recently, Ben David et al. generalized and further formalized this idea. The specific flagging and marking techniques in the E F R B tree paper were inspired by earlier work by Fomitchev and Ruppert. Note that if descriptors are word aligned on a thirty two bit architecture, then the two least significant bits of any descriptor pointer are zero, so these two bits are conceptually free to store the state. On a sixty four bit architecture, three bits are free.
The text delves into the intricacies of concurrent data structures, specifically focusing on the behavior of nodes within an EFRB tree. When a node is marked as "locked," its update field is designed to point to a descriptor. This descriptor encapsulates the state of the lock, indicating the operation that is currently holding it. This mechanism allows for a "helping" paradigm where other threads can assist the thread that acquired the lock, rather than simply blocking. The adoption of compare and swap, or CAS operations, is crucial here. CAS is an atomic instruction that performs a read-modify-write operation; it reads a value, compares it to an expected value, and if they match, writes a new value. This atomicity ensures that intermediate states are not exposed to other threads, preventing race conditions during critical updates.

The text highlights the importance of idempotency in these helping operations. An operation is idempotent if applying it multiple times has the same effect as applying it once. This property is essential for concurrent helping schemes because a helper thread might execute a CAS operation multiple times if the lock is contended, and it should not corrupt the data structure if it retries. The rationale is that if each CAS step is idempotent, the entire sequence of operations performed by a helper thread, even if executed multiple times or out of order, will still lead to a correct final state. This concept of idempotency is also seen in concepts like read operations on shared memory, where multiple reads are inherently idempotent.

The EFRB tree node's structure is described as conceptually holding two separate fields: state and information. The state field can assume one of four possible values: Clean, IFlag, DFlag, or Mark. These states carry significant meaning. A Clean state signifies an unlocked node. The IFlag and DFlag states indicate that the node is "locked" for an insert or delete operation, respectively. The Mark state is used to indicate that the node is locked for a deletion operation, but critically, this lock can be released by the operation that originally deleted it, allowing for subsequent modifications. When a node is "locked" by an operation, the information field typically points to the descriptor for that specific operation. For an insert operation, this would be an insert descriptor, and for a delete, a delete descriptor. Notably, child pointers within a node are only modified by the operation that owns the lock on that node. Furthermore, a node's state is immutable once set, meaning it cannot be changed without first "unlocking" it by the operation that locked it. This immutability of the state field contributes to the predictable behavior of the data structure under concurrent access.

The "Lookup Operation" section describes a particularly elegant property of EFRB trees: they can perform lookup operations without explicit synchronization between threads. This is a significant performance advantage, as it minimizes the need for locks and allows for higher concurrency. A lookup operation behaves similarly to a sequential external Binary Search Tree. The process involves traversing the tree starting from the root, guided by comparisons with the key being searched. The traversal continues down the tree, branching left or right based on whether the target key is less than or greater than the key at the current node. This continues until a leaf node is reached. If the leaf node contains the sought-after key, the operation returns true; otherwise, it returns false. This lock-free lookup is a testament to the careful design of the EFRB tree, allowing read operations to proceed concurrently with write operations without interference, a common goal in designing high-performance concurrent data structures.

The footnotes provide additional context and historical grounding. Footnote two references the foundational work on "lock-free mutual exclusion," attributing the concept of a "cooperative technique" to Barnes. This technique is seen as a specialization of Barnes' broader approach, which leverages compare and swap operations instead of traditional locking mechanisms. The idea is further elaborated by Ben-David and colleagues, who generalized and formalized these techniques in their EFRB tree research. This lineage highlights the evolution of concurrent programming paradigms, moving away from explicit locking towards more sophisticated atomic operations to manage shared mutable state. Footnote three delves into the memory representation of descriptors. It explains that on a thirty-two-bit architecture, descriptor pointers, if word-aligned, can utilize the two least significant bits for storing state information, effectively doubling as the DFlag and Mark bits. This efficient use of memory is a common optimization in systems programming, where every bit can be precious. On a sixty-four-bit architecture, these two bits are conceptually free, meaning they can be repurposed without impacting the integrity of the pointer itself.
