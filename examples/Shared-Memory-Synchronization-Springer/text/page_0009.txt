1.4 Safety and Liveness 9

Most of our discussions of correctness will focus on safety properties. Interestingly,
deadlock freedom, which one might initially imagine to be a matter of liveness, is actually
one of safety: because deadlock can be described as a predicate that takes the current system
state as input, deadlock freedom simply insists that the predicate be false in all reachable
states.
Section one point four: Safety and Liveness.

Most of our discussions of correctness will focus on safety properties. Interestingly, deadlock freedom, which one might initially imagine to be a matter of liveness, is actually one of safety: because deadlock can be described as a predicate that takes the current system state as input, deadlock freedom simply insists that the predicate be false in all reachable states.
The fundamental pursuit in formal methods and concurrent system design is ensuring system correctness. This overarching goal is typically decomposed into two distinct, yet complementary, categories of properties: safety and liveness.

Safety properties assert that "nothing bad ever happens." They are characterized by their invariant nature, meaning that a particular undesirable state or event will never be reached throughout the system's execution. If a safety property is violated, it is often detectable at the exact moment the forbidden state is entered, or the forbidden event occurs. Examples include mutual exclusion, which dictates that two processes can never simultaneously access a critical section, or type safety, ensuring that a program never attempts an invalid memory access. These properties describe characteristics that must hold true for all reachable states of the system.

In contrast, liveness properties declare that "something good eventually happens." They focus on progress and termination. For instance, a liveness property might specify that a process requesting a resource will eventually acquire it, or that a system will eventually produce an output. Liveness violations are generally harder to detect in finite time, as they involve the absence of progress over an unbounded future; one cannot conclusively say "it will never happen" after a finite period. Common examples include starvation freedom, which guarantees a process will eventually make progress, and termination, ensuring a computation eventually completes.

The text highlights an intriguing nuance regarding deadlock freedom. Intuitively, one might classify deadlock freedom as a liveness property because it implies that processes will eventually make progress, or that the system will not halt indefinitely. However, from a rigorous formal perspective, deadlock freedom is correctly categorized as a safety property. This classification stems from how the absence of deadlock is formally defined. A system is in a deadlocked state if a set of processes are blocked indefinitely, each waiting for a resource held by another process in the same set, thus forming a circular dependency. This condition of deadlock can be precisely described as a predicate over the current system state, encompassing the allocation of resources and the wait queue of each process.

For a system to exhibit deadlock freedom, this predicate, representing the presence of a deadlocked state, must never evaluate to true in any reachable state of the system. The assertion "the system is never deadlocked" is a statement about an invariant condition: the absence of a specific undesirable configuration at any point in time. If, at any moment, the system enters a state where this deadlock predicate is true, a safety property has been definitively violated. The "bad thing" — the deadlock itself — has occurred. This "never occur" characteristic is the defining trait of a safety property, distinguishing it from liveness properties, which pertain to eventual outcomes. The analysis of reachable states, often performed through techniques like model checking, is crucial for verifying such properties by exhaustively exploring the state space to ensure the undesirable predicate is indeed never satisfied.
