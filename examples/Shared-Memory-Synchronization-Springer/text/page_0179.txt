8.10 Higher-Level Constructions 183

k-CSS takes k addresses, k expected values, and one new value; it then atomically checks
if all addresses contain their expected values and, if so, changes the first address to its new
value and returns true. Otherwise, it simply returns false. Unfortunately, because k-CSS
updates only a single location, it cannot easily be used to, say, remove a node and mark it
as deleted so it is not subsequently changed erroneously.

The more expressive k-CAS operation takes k addresses, k expected values, and k new
values; it then atomically checks if all addresses contain their expected values and, if so,
changes each address to its new value and returns true. Otherwise, it simply returns false.

LLX and SCX are slightly different in that they operate on nodes rather than individual
addresses. LLX(u) returns a snapshot of the contents of node u. SCX(D, F, f,n) takes a
sequence D of dependency nodes that LLX has been invoked on, a sequence F' of nodes to
finalize, a field f and a value n; it then atomically checks whether any of the nodes in D have
been changed since LLX was last invoked on them and, if not, stores n in f and finalizes the
nodes in F, preventing them from being changed by future SCX operations. LLX and SCX
are less expressive than k-CAS, but can be implemented more efficiently. The algorithms for
LLX and SCX were inspired by the EFRB tree and generalized its ideas.

Recently, a generalization of k-CAS, called PathCAS, was introduced to make it easier to
use k-CAS to design lock-free data structures. Note that using k-CAS to design, for example,
a lock-free tree is not trivial. Although k-CAS makes it easy to change multiple addresses
atomically, one still needs to reason about the atomicity of searches and, as we’ve seen in
Sec. 8.6.1, even atomic updates in an internal BST can foil naive searches. PathCAS provides
operations to visit a node; validate that no node has changed since it was visited (returning
true if there were no changes and false otherwise); and add a triple consisting of an address,
expected value, and new value to the accumulated path. It then provides an exec operation,
which performs a k-CAS using the added triples, and a vexec operation, which atomically
performs the combined operation {if validate() then exec()}.

Transactional memory (TM) 1s perhaps the most expressive synchronization primitive
yet to be proposed. It allows an arbitrary sequence of reads and writes to be encapsulated in
a transaction that either commits and takes effect atomically, or aborts and does not perform
any of its writes. The term software transactional memory (STM) was coined by Shavit and
Touitou (1995). Inspired by the hardware proposal of Herlihy and Moss (1993), the original
Shavit and Touitou-style STM is very similar to a lock-free software implementation of
k-CAS. Most subsequent STM systems have extended this functionality to accommodate
dynamic operations, in which the full set of locations to be accessed is not known in advance.
We will consider TM in more detail in Chapter 9. Most STM systems use locks “under the
hood”; a few, however, are lock free or obstruction free.
Eight point one zero Higher Level Constructions One hundred eighty three. K C S S takes k addresses, k expected values, and one new value; it then atomically checks if all addresses contain their expected values and, if so, changes the first address to its new value and returns true. Otherwise, it simply returns false. Unfortunately, because K C S S updates only a single location, it cannot easily be used to, say, remove a node and mark it as deleted so it is not subsequently changed erroneously. The more expressive k C A S operation takes k addresses, k expected values, and k new values; it then atomically checks if all addresses contain their expected values and, if so, changes each address to its new value and returns true. Otherwise, it simply returns false. L L X and S C X are slightly different in that they operate on nodes rather than individual addresses. L L X of u returns a snapshot of the contents of node u. S C X of D comma F comma f comma n takes a sequence D of dependency nodes that L L X has been invoked on, a sequence F of nodes to finalize, a field f and a value n; it then atomically checks whether any of the nodes in D have been changed since L L X was last invoked on them and, if not, stores n in f and finalizes the nodes in F, preventing them from being changed by future S C X operations. L L X and S C X are less expressive than k C A S, but can be implemented more efficiently. The algorithms for L L X and S C X were inspired by the E F R B tree and generalized its ideas. Recently, a generalization of k C A S, called Path C A S, was introduced to make it easier to use k C A S to design lock free data structures. Note that using k C A S to design, for example, a lock free tree is not trivial. Although k C A S makes it easy to change multiple addresses atomically, one still needs to reason about the atomicity of searches and, as we’ve seen in Section eight point six point one, even atomic updates in an internal B S T can foil naive searches. Path C A S provides operations to visit a node; validate that no node has changed since it was visited returning true if there were no changes and false otherwise; and add a triple consisting of an address, expected value, and new value to the accumulated path. It then provides an exec operation, which performs a k C A S using the added triples, and a Vexec operation, which atomically performs the combined operation of validate if validate is true then exec. Transactional memory is perhaps the most expressive synchronization primitive yet to be proposed. It allows an arbitrary sequence of reads and writes to be encapsulated in a transaction that either commits and takes effect atomically, or aborts and does not perform any of its writes. The term software transactional memory is coined by Shavit and Touitou in 1995. Inspired by the hardware proposal of Herlihy and Moss 1993, the original Shavit and Touitou style S T M is very similar to a lock free software implementation of k C A S. Most subsequent S T M systems have extended this functionality to accommodate dynamic operations, in which the full set of locations to be accessed is not known in advance. We will consider T M in more detail in Chapter 9. Most S T M systems use locks under the hood; a few, however, are lock free or obstruction free.
The text delves into advanced synchronization primitives, specifically focusing on variations of compare and swap (CAS) operations and their application in building lock-free data structures.  A fundamental concept discussed is k-Compare And Swap, or k-CAS.  Unlike a standard CAS which operates on a single memory location, k-CAS targets *k* memory locations simultaneously.  It accepts *k* addresses, *k* expected values for those addresses, and a single new value. The operation atomically checks if all *k* specified addresses hold their respective expected values. If they do, it updates all *k* locations with the new value and returns true. If any of the expected values do not match, the operation returns false without performing any updates.  The limitation of a simpler k-CAS is highlighted: it cannot easily express operations like removing a node from a linked list and marking it as deleted, because that might involve updating multiple linked list pointers.

The text then introduces two related operations: LLX and SCX. These operations are described as being slightly different from k-CAS in that they operate on sequences of addresses rather than individual ones. Specifically, LLX, when invoked on a node *u*, returns a snapshot of the contents of that node *u*.  However, the crucial distinction for LLX and SCX lies in their handling of dependency detection. An LLX operation, when invoked on a sequence of nodes, effectively "remembers" the state of those nodes. Subsequent SCX operations can then be performed on a sequence of nodes *F*, along with a field *f* and a value *n*. The SCX operation atomically checks whether any of the nodes in the dependency sequence *D* (recorded by prior LLX calls) have been modified since the LLX was invoked. If none have been modified, and the specific field *f* of the nodes in *F* contain the expected value *n*, then the SCX proceeds with an update and returns true. Otherwise, it returns false. This mechanism allows for more complex, multi-location atomic updates by providing a way to detect concurrent modifications. LLX and SCX are less expressive than k-CAS, but they can be implemented more efficiently, with algorithms for LLX and SCX being inspired by the EFRB tree and generalized into more comprehensive ideas.

The text mentions that a generalization of k-CAS, called PathCAS, was introduced to simplify the design of lock-free data structures, citing the example of a lock-free tree. It acknowledges that designing such structures is non-trivial. A key challenge is ensuring atomicity for complex operations like searching and updating multiple nodes within a structure. For instance, a simple atomic update to an internal binary search tree can be foiled by naive search operations that might not observe a consistent state. PathCAS, by enabling the atomic modification of multiple locations, aims to address these complexities. PathCAS operations are described as visiting a node, validating that the node has not changed since it was visited, returning true if it hasn't and false otherwise. Additionally, it adds a triple—consisting of an address, an expected value, and a new value—to an accumulated path. A 'vexec' operation then executes a sequence of these collected triples, performing the combined operation if all validations succeed.

A significant portion of the text is dedicated to Transactional Memory (TM). TM is presented as a highly expressive synchronization primitive that allows a sequence of reads and writes to be encapsulated within a transaction. These transactions can either commit all their modifications atomically or abort, discarding all their writes. The concept of Software Transactional Memory (STM) is attributed to Herlihy and Touitou (1995), and it is described as a software implementation that mimics the functionality of hardware transactional memory. Shavit and Touitou-style STM is presented as very similar to a lock-free software implementation. The evolution of STM systems is noted, where they have been extended to accommodate dynamic operations where the exact set of memory locations to be accessed is not known in advance. The text indicates that Transactional Memory will be considered in more detail in Chapter 9, and it notes that most STM systems either employ locking mechanisms or are obstruction free, meaning they guarantee progress for a single thread if it runs in isolation.
