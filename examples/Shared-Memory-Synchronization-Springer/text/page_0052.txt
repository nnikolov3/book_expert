34 Memory Models 53

Source program —— (Set of) abstract
and input I executions

anguage
semantics )
Language Required A
implementation correspondence

executions

(= of) concrete mm mm

Figure 3.2 Program executions, semantics, and implementations. A language implementation is
considered safe only if the output of every realizable execution agrees with that of some abstract
execution allowed by language semantics for the given program and input.

3.4.1 Formal Framework

Informally, a memory model specifies which values (i.e., which writes) may be seen by
any given read. At the language level, more precise definitions depend on the notion of an
abstract program execution.

Programming language semantics are typically defined in terms of execution on some
abstract machine, with language-appropriate built-in types, control-flow constructs, etc. For
a given source program and input, an abstract execution is a set of sequences, one per
thread, of reads, writes, and other atomic program steps, each of which inspects and/or
changes the state of the abstract machine (i.e., memory). For any given program and input,
certain executions of the abstract machine are said to be valid according to the language’s
semantics. Language semantics can be seen, constructively, as a mapping from programs
and inputs to (possibly infinite) sets of valid executions. The semantics can also be seen,
nonconstructively, as a predicate: given a program, its input, and an abstract execution, 1s
the execution valid?

For the sake of convenience, the remainder of this section adopts the nonconstructive point
of view, at least with respect to the memory model. In practice, it is the language implementer
who needs to generate an execution—a concrete execution—for a given program and input.
If a language implementation is safe, then given a well formed source program and input,
any execution generated by the implementation will correspond to (produce the same output
as) some valid abstract execution of that program on that input (Figure 3.2). If the language
implementation is live, then it will generate at least one such concrete execution whenever
the set of abstract executions is nonempty. To show that a language implementation is safe
(a task beyond the scope of this monograph), one can define a mapping from concrete to
abstract executions, and then demonstrate that all the resulting abstract executions will be
valid.
three point four Memory Models

Figure three point two illustrates program executions, semantics, and implementations. In this diagram, a "Source program and input" block is shown. This block is connected by an arrow labeled "Language semantics" to a block titled "Set of abstract executions". The "Source program and input" block is also connected by an arrow labeled "Language implementation" to a block titled "Set of concrete executions". Finally, there is a dashed arrow labeled "Required correspondence" connecting the "Set of concrete executions" block to the "Set of abstract executions" block. A language implementation is considered safe only if the output of every realizable execution agrees with that of some abstract execution allowed by language semantics for the given program and input.

three point four point one Formal Framework

Informally, a memory model specifies which values, that is, which writes, may be seen by any given read. At the language level, more precise definitions depend on the notion of an abstract program execution.

Programming language semantics are typically defined in terms of execution on some abstract machine, with language appropriate built in types, control flow constructs, et cetera. For a given source program and input, an abstract execution is a set of sequences, one per thread, of reads, writes, and other atomic program steps, each of which inspects and or changes the state of the abstract machine, that is, memory. For any given program and input, certain executions of the abstract machine are said to be valid according to the language's semantics. Language semantics can be seen, constructively, as a mapping from programs and inputs to possibly infinite sets of valid executions. The semantics can also be seen, non constructively, as a predicate: given a program, its input, and an abstract execution, is the execution valid?

For the sake of convenience, the remainder of this section adopts the non constructive point of view, at least with respect to the memory model. In practice, it is the language implementer who needs to generate an execution — a concrete execution — for a given program and input. If a language implementation is safe, then given a well formed source program and input, any execution generated by the implementation will correspond to, and produce the same output as, some valid abstract execution of that program on that input, as shown in Figure three point two. If the language implementation is live, then it will generate at least one such concrete execution whenever the set of abstract executions is non empty. To show that a language implementation is safe (a task beyond the scope of this monograph), one can define a mapping from concrete to abstract executions, and then demonstrate that all the resulting abstract executions will be valid.
This segment introduces a foundational framework for understanding program execution within the context of memory models, a critical area in concurrent system design and programming language theory. The central theme revolves around formalizing the relationship between a program's specified behavior and its actual behavior when executed.

At the highest level, the architectural diagram titled "Program executions, semantics, and implementations" provides a visual representation of these conceptual relationships. Spatially, in the upper left, we have a component labeled "Source program and input," representing the initial state of any computation. From this origin, two distinct paths diverge. One path, depicted by a solid arrow flowing towards the upper right, leads to a component labeled "Set of abstract executions." This transition is governed by "Language semantics," indicating that the formal rules of a programming language dictate the set of all theoretically valid behaviors for a given program and its input. These abstract executions represent the ideal, mathematically defined outcomes.

The second path, also emanating from the "Source program and input" and represented by a solid arrow, flows downwards and then rightwards to a component labeled "Set of concrete executions" located at the bottom center. This pathway is labeled "Language implementation," signifying the role of a compiler, interpreter, or runtime system in translating the source program into actual, executable operations on a physical machine, yielding concrete, observable behaviors.

Crucially, a dashed arrow labeled "Required correspondence" connects the "Set of concrete executions" at the bottom to the "Set of abstract executions" at the top right, flowing upwards and to the left. This dashed arrow signifies a critical validation criterion. It postulates that for a language implementation to be considered correct, its concrete executions must align with the abstract executions defined by the language's semantics. Specifically, the diagram's accompanying caption clarifies that a language implementation is deemed *safe* if the output of every concrete execution it produces corresponds to at least one abstract execution permitted by the language's semantics for the given program and input. This ensures that the physical execution adheres to the theoretical guarantees.

Transitioning to the formal framework, a memory model is introduced as a specification governing which values a read operation may observe. In essence, it defines the permissible interleavings and visibility of memory operations across different computational entities, such as threads or processors. This is a non-trivial problem in modern, optimized hardware, where operations may be reordered or cached, leading to a disparity between program order and execution order.

The framework builds upon the concept of an *abstract program execution*. This is a precise theoretical construct, representing the behavior of a program on an *abstract machine*. An abstract execution is described as a collection of sequences, one for each thread, detailing the atomic steps—including reads, writes, and control flow operations—that inspect and modify the abstract machine's state, notably its memory. The core idea is that not all possible sequences of operations are valid; rather, certain sequences are designated as *valid* by the language's semantics. These semantics can be conceptualized either constructively, by defining a mapping from programs to a set of valid executions, or nonconstructively, by providing a predicate that determines whether a given program, input, and abstract execution combination is valid. The latter, nonconstructive approach, is adopted here for its practical convenience in formal reasoning.

The analysis then distinguishes between two fundamental properties of a language implementation: *safety* and *liveness*. A language implementation is defined as *safe* if, for any valid source program and its input, every concrete execution generated by the implementation yields an output that aligns with *some* valid abstract execution of that program on that given input. This property is paramount as it guarantees that the implementation never produces an incorrect or unexpected result according to the language specification. It ensures that "nothing bad happens."

Conversely, a language implementation is considered *live* if it is capable of generating at least one concrete execution whenever the set of valid abstract executions for a given program and input is not empty. This means that if there exists a valid way for the program to complete or progress according to its semantics, the implementation must be able to achieve it. Liveness ensures that "something good eventually happens," preventing scenarios where a safe implementation might simply deadlock or loop infinitely without ever producing a valid outcome, even when one is theoretically possible.

The text also provides insight into proving safety: one can establish a formal mapping from the observed concrete executions back to the abstract execution space. If all mapped concrete executions correspond to valid abstract executions, then the implementation's safety is demonstrated. This rigorous approach is crucial for building reliable software and hardware systems, particularly when dealing with complex behaviors inherent in memory models for parallel and distributed computing.
