Software Transactional Memory, or S T M, systems are designed to manage concurrent access to shared data by multiple transactions. These systems can be categorized based on their conflict resolution timing, with lazy systems deferring conflict detection and resolution until a transaction is ready to commit, and eager or strict systems resolving conflicts early, even before transactions finish execution. A mixed approach resolves write-write conflicts early but read-write conflicts late.

To detect conflicts, an S T M system must track the accesses performed by each transaction. This can be achieved by logging accesses locally in each thread and intersecting the logs of transactions that overlap in time at commit time. Alternatively, shared metadata can be employed for access tracking, with some systems using a hash function keyed on the address of the accessed location to index into a global table of ownership records, or O R E C S.

Lazy and mixed conflict resolution strategies have the advantage that readers can avoid updating metadata to make themselves visible to writers, a concept known as invisible readers. This can improve the performance of read-only or read-mostly transactions by reducing metadata updates, which can induce cache misses. However, invisible readers reduce the flexibility of contention management, as a writer cannot defer to a reader it cannot see.

Validation is a crucial concept in ensuring transactional semantics, specifically serializability. In an S T M system, validation guarantees that no other transaction can modify locations that a given transaction has read or written, thereby preventing conflicts. For a system to achieve strict serializability, validation must occur throughout the transaction's execution, not solely at commit time. A maximally pessimistic system may choose to validate immediately after every shared read, preserving opacity, while a more optimistic system may delay validation until the program is about to execute a dangerous operation, tolerating zombie transactions.

Contention management addresses the decision of which contending transactions should proceed and which should abort or wait. Waiting may be viable if the transaction that continues is a reader working with the original value of the conflicting data, or if there is a possibility that the transaction that continues may ultimately fail to commit. The system may also dynamically adjust behavior to reduce contention, potentially by altering transaction scheduling, to ensure fairness among transactions or threads.

The design space of S T M systems offers various dimensions, including conflict resolution, contention management, and access tracking. The R S T M suite provides interchangeable S T M back ends for C++, allowing exploration of these alternatives. However, the design space dimensions are not fully orthogonal, with invisible readers reducing the flexibility of contention management, and private undo logs and access logs having limitations in nonblocking systems and eager conflict resolution.

Buffering of speculative state is another critical aspect of S T M systems. Transactions may access thread-private data, which might need to be rolled back if the transaction aborts. Variables declared within the lexical scope of an atomic block require no load-store instrumentation, as their lifetimes are bounded by the transaction. However, dynamically allocated data requires special treatment, with malloc and free needing to be made transaction-safe.

Most S T M systems are prone to false sharing, where accesses to disjoint data are covered by the same metadata. This can lead to unnecessary aborts due to the mismatch between access and metadata granularity. Redo and undo logging also face challenges with granularity, as logging at full-word granularity may overwrite nontransactionally updated values. To maintain correctness, the compiler must ensure that transactional and nontransactional instructions never access different pieces of a logging-granularity block, or the S T M system must log at the finest possible granularity.

Access tracking and conflict resolution are fundamental to S T M systems. Two concurrent transactions conflict if they access the same location and at least one of them writes it. Conflicts can be resolved by aborting either transaction or stalling the transaction that makes its access second. Without prior knowledge of read and write sets, an S T M system must speculate and be prepared to roll back at least up to the first conflict. There is a tradeoff between eager and lazy conflict resolution, with lazy conflict resolution potentially leading to unnecessary aborts if a transaction eventually aborts.

In summary, S T M systems must navigate the complexities of conflict resolution, contention management, and access tracking to ensure correct and efficient execution of concurrent transactions. The choice of conflict resolution strategy, contention management approach, and access tracking mechanism can significantly impact the performance and scalability of S T M systems. By understanding these tradeoffs and challenges, developers can design and implement effective S T M systems that meet the needs of modern concurrent programming.
