Transactional memory systems have been designed to be plug-compatible with traditional cross-chip cache coherence protocols. In the IBM Blue Gene Q, designers chose to use an unmodified processor core and implement hardware transactional memory, or H T M, entirely within the memory system. To accommodate hardware limitations, most H T M systems require software backup. In simpler scenarios, a fallback to a global lock mechanism might be employed. More ambitious designs consider hybrid transactional memory systems, enabling compatible software transactional memory, or S T M, and H T M implementations to coexist.

The discussion proceeds to examine aspects of the transactional memory design space, specifically focusing on speculative lock elision as an alternative programming strategy. This strategy, potentially supported by a separate application binary interface, or A B I, is designed to execute traditional lock-based critical sections. The text indicates that alternative approaches for mixing hardware and software support for transactional memory will be explored.

Current transactional memory research encompasses a broad spectrum of academic designs and commercial implementations. Notable academic projects include the Azul Systems Vega two and three, and the Rock processor developed by Dice and colleagues in two thousand nine. Three independently developed systems are also highlighted: the Blue Gene Q, discussed by Wang and colleagues in two thousand twelve; the z E C twelve mainframe, from I B M, as detailed by Jacobi and colleagues in two thousand twelve; and Power eight, also from I B M, with work by Le and colleagues in two thousand fifteen. Additionally, the text mentions Intel's Transactional Synchronization Extensions, or T S X, for its x eight six processors, originating with the Haswell generation, and Arm's v nine instruction set, specifically its Transactional Memory Extension, or T M E, from Mann in two thousand nineteen.

The landscape of commercial transactional memory appears to be in flux. As of early two thousand twenty three, the future of widespread commercial H T M implementations is uncertain. While I B M has maintained transactional memory support in its z fifteen architecture, it has discontinued transactional memory support in Power ten, as noted by I B M in two thousand twenty. A M D has also published an early proposal, with subsequent adoption of Intel's T S X. Intel, for its part, has disabled T S X by default on recent x eight six processors, citing concerns about side-channel information leaks, as reported by Intel in two thousand twenty one b and Mott in two thousand twenty one. And Arm's T M E design is considered too nascent to have gathered significant real-world operational experience.

Section nine point two point one delves into the dimensions of the H T M design space. It begins by defining the Application Binary Interface, or A B I, in the context of transactional memory. Most H T M implementations include specialized instructions to initiate a transaction, and, by extension, to commit or abort the current transaction. These instructions are generically referred to as t x start, t x abort, and t x commit. Some implementations also incorporate mechanisms for suspending and resuming transactions, or for querying their status.

When a transaction is active, load and store instructions are treated speculatively. The hardware implicitly buffers these updates and meticulously performs access tracking and conflict detection. To facilitate this, some systems provide specialized instructions for memory access, such as spinning on a condition or saving information for use by a debugger or other system utilities. These operations are considered speculative because their outcome is dependent on the successful completion of the ongoing transaction.

On an abort, a transaction may retry automatically, generally no more than some fixed number of times, retry the transaction under protection of an implicit global lock, or jump to a software handler that figures out what to do, for example, retry under protection of a software lock. In Intel's R T M, Restricted Transactional Memory, part of T S X, the address of the handler is an argument to the t x start instruction. In I B M's z and Power T M, and in Arm T M E, t x start sets a condition code, in the style of the P O S I X setjmp routine, to indicate whether the transaction is beginning or has just aborted. This code is typically checked by the following instruction. With either style of abort delivery, any speculative updates performed so far will be discarded.

In the I B M Blue Gene Q, H T M operations were triggered not with special instructions but with stores to special locations in I O space. Conflicts would raise an interrupt, which was fielded by the O S kernel.

The subsequent section addresses the challenge of managing speculative writes within a transactional system. Processors can buffer these speculative updates, and various proposals exist for how to achieve this. Herlihy and Moss's original proposal involved a special transactional cache located adjacent to the L one cache. Sun's prototype Rock processor, which was not brought to market, utilized a small number of speculative stores, which were kept in a store buffer, a component typically found deeper in the cache hierarchy. Other academic proposals suggested buffering speculative updates at a level of the cache hierarchy, with the aim of hiding these updates until the transaction commits. Some systems, like those described for Blue Gene Q and the original Herlihy and Moss proposal, kept both the original data and the speculative version in a line within the cache. Most systems, however, buffer only the speculative version, and this buffering can occur at various levels of the cache.

Whatever the physical location used to buffer speculative updates, there will be a limit on the space available. In most H T M systems, a transaction will abort if it overflows this space, or exceeds the supported degree of associativity. Several academic groups have proposed mechanisms to spill excess updates to virtual memory and continue to execute a hardware transaction of effectively unbounded size.

Among commercial machines, as of two thousand twenty three, z T M provides nontransactional stores, ordered at commit or abort time, but not loads. Sun's Rock provided both, with stores again ordered at commit abort. Intel's T S X originally provided neither, but Sapphire Rapids processors introduced a Suspend Load Address Tracking mechanism that supports nontransactional loads. Power T M allows transactions to enter a suspended state, where both loads and stores will happen immediately and for real. Blue Gene Q facilities could be used to similar ends, but only with kernel assistance. On both the Power eight and Blue Gene Q, the programmer must be aware of the potential for paradoxical memory ordering.

Transactional memory systems require mechanisms to manage the state of in-core resources, such as registers, to facilitate transaction commits or rollbacks. In many transactional memory implementations, a crucial operation involves checkpointing these registers at the beginning of a transaction, often referred to as t x begin. Upon a transaction abort, these saved register states are restored. Some systems, like certain configurations of the Azul Vega processors, delegate this checkpointing and restoration responsibility to software. This approach necessitates explicit instructions within the program to save register states before a transaction and to reload them if the transaction fails.

A primary challenge in transactional memory is effectively tracking memory accesses and resolving conflicts, particularly in systems employing existing cache coherence protocols. A common strategy to identify conflicts is to augment the cache coherence states, such as those defined by the M E S I protocol, with an additional speculative bit. This bit indicates whether a cache line has been modified speculatively within the current transaction. When a cache line is accessed speculatively, its corresponding tag might be marked as speculative modified, speculative shared, or speculative invalid. This explicit tagging allows the system to distinguish between regular memory operations and speculative ones, enabling finer-grained conflict detection.

The implementation of speculative buffering within the cache hierarchy can vary significantly across different transactional memory systems. In many commercial transactional memory implementations, speculative updates and their associated tag information are buffered within the caches. For instance, Azul's transactional memory implementation buffers these speculative updates directly in the L one cache. In contrast, systems like Blue Gene Q buffer speculative operations in the L two cache, with limited support for the L one caches, which are typically designed to handle speculative accesses with very little overhead, such as a small miss penalty. In a short-running mode, speculative updates might be directly visible to the L one cache. Alternatively, in a long-running mode, the operating system might manage the mapping of virtual to physical addresses, and the L one cache might hold these mappings, with separate threads handling different physical addresses, and the L one to L two path being managed by hardware.

The z E C twelve processor adopts a distinct approach to handling speculative accesses. It tracks and buffers speculative operations that would normally be write-through to the L two and L three caches. To mitigate the overhead of speculative loads, designers introduced a sixty-four-byte cache line. During a transaction, stores to the same cache line are coalesced. This coalescing, even for bursts of operations, allows the gathering cache to serve multiple stores per cycle, effectively reducing incoming bandwidth to the L three cache, even under normal operating conditions.

Intel's Haswell processor and its successors incorporate speculative access tracking and buffering at the cache line granularity, within the L one cache itself. Conflicts are primarily detected for speculative loads, though not for speculative stores, by leveraging the existing cache coherence protocol. The associativity of the L one cache is critical here, and it is summarized in a hardware structure, often akin to a Bloom filter, which is checked against incoming coherence requests. This design aims to accommodate transactions with extensive read sets. For example, the I B M Power eight processor buffers speculative operations within the L two cache, utilizing a separate set of sixty-four tags that are dynamically managed, thereby handling speculative updates associated with such operations.
