The concept of transactional memory is a mechanism for simplifying concurrent programming by allowing operations to be executed atomically. Power T M, a system that supports transactional memory, introduces an instruction set architecture enhancement. This enhancement enables certain code constructs to operate safely within a transactional mode, which is distinct from non-transactional execution. The presented idiom illustrates a common pattern: initiating a transaction with tx begin, followed by operations that might include reading lock values. If a failure condition is met, such as not holding a required lock, the transaction is aborted. Otherwise, if a commit condition, represented by tx commit, is satisfied, the transaction proceeds, potentially including the release of a lock after a successful commit.

The concept of transactional memory, as originally proposed by Ravi Rajwar in his two thousand two thesis, played a crucial role in Intel's Transactional Synchronization Extensions, or T S X. T S X provided two primary implementations: Hardware Lock Elision, or H L E, and Restricted Transactional Memory, or R T M. R T M offers an approximation of transactional behavior, enabling developers to instruct the hardware to begin, commit, or abort a transaction and to query its current state.

Lock Subscription is a technique for implementing atomic blocks, often used with best-effort transactional memory. This approach involves a fallback transaction that writes to a location, effectively subscribing to changes. If a hardware transaction is active, it might cause this fallback transaction to abort. This can occur if the fallback transaction modifies a location that was previously read by the hardware transaction, or if the hardware transaction attempts to read a location that is updated by the fallback transaction before the hardware transaction commits.

A potential inconsistency arises when a hardware transaction reads location X and Y, which are updated atomically, and then the fallback transaction modifies X before the hardware transaction reads X again but after it has already read Y. This leads to a race condition where the hardware transaction might incorrectly commit. The document highlights a potential issue with lazy subscription, where a hardware transaction might observe inconsistent values or undergo logically impossible branches if it doesn't involve careful sandboxing on the hardware side.

Figure nine point one presents a conceptual implementation of a ticket lock, a synchronization primitive. The lock class is defined with two atomic integer members: next underscore ticket, which represents the next available ticket to be issued, initialized to zero, and now underscore serving, which indicates the ticket of the thread currently holding the lock, also initialized to zero. A constant base value is also declared, implicitly used in scheduling or timing.

The lock dot acquire method begins by atomically fetching and incrementing next underscore ticket to obtain a unique my underscore ticket for the requesting thread. It then enters a loop. Inside the loop, it atomically loads the current value of now underscore serving into ns. The loop continues until ns is equal to my underscore ticket, signifying that the thread's turn has arrived. To prevent excessive spinning and to yield the processor, a pause instruction is executed, scaled by the difference between base and my underscore ticket.

The lock dot release method first atomically loads now underscore serving. It then attempts to atomically update now underscore serving by incrementing it by one using a Compare-And-Swap, or C A S, operation. The next underscore ticket is compared to the old value of now underscore serving plus one, and if they match, now underscore serving is updated. This operation is performed using X Release tagged instructions, indicating a release operation.

The accompanying text discusses Hardware Lock Elision, or H L E, an optimization technique often employed on architectures like those supporting T S X. On legacy machines without H L E, executing R T M instructions would result in an unsupported instruction exception. H L E provides a backward-compatible approach by allowing traditional lock acquire and release instructions to be tagged with X Acquire or X Release prefix bytes.

Hybrid transactional memory, or H T M, systems aim to combine the performance advantages of hardware transactional memory with the flexibility and compatibility of software transactional memory. While pure hardware transactional memory implementations can achieve significant speedups, they often face limitations and may require applications to be re-engineered to fully leverage their capabilities. Hybrid approaches seek to mitigate these limitations by integrating hardware acceleration for specific, performance-critical aspects of transaction management, while relying on software for broader compatibility and handling of complex scenarios.

Several styles of hybrid transactional memory have been proposed. Some systems may implement the core transaction logic primarily in software, using hardware only to accelerate certain operations, such as speculative writes or conflict detection. In other designs, the hardware might manage a significant portion of the transaction's state and execution, with software providing support for a subset of transactional operations or handling situations where hardware mechanisms fall short.

Experimental results with a variety of S T M systems suggest a baseline overhead, single-thread slowdown, of three to ten times for atomic operations. Several factors contribute to this overhead, including conflict detection, the buffering of speculative writes, validation to ensure consistency, and conflict resolution. All of these are potentially amenable to hardware acceleration. Saha et al. propose to simplify conflict detection by providing hardware mark bits on cache lines. Set and queried by software, these bits are cleared when a cache line is invalidated.

To avoid the need to poll the bits, Spear et al. propose a general-purpose alert-on-update mechanism that triggers a software handler when a marked line is accessed remotely. Minh et al. propose an alternative conflict detection mechanism based on hardware read and write signatures, possibly using Bloom filters. Shriraman et al. propose to combine in-cache hardware buffering of speculative cache lines with software conflict detection and resolution. Alert-on-update provides immediate notification of conflicts, eliminating the need for validation.

In subsequent work, the authors add signatures and conflict summary tables; these support eager conflict detection in hardware, leaving software responsible only for conflict resolution, which may be lazy if desired. As suggested by Hill et al., the decoupling of mechanisms for access tracking, buffering, notification, etc. serves to increase their generality. In various other combinations, they can be used for such non-T M applications as debugging, fine-grain protection, memory management, and active messaging.
