The discussion delves into the concept of monitors in concurrent programming, addressing potential pitfalls and introducing language-specific implementations. One challenge arises with nested monitors, where a thread may need to wait on an inner monitor, referred to as M two, while holding a lock on an outer monitor, referred to as M one. A proposed solution involves releasing the outer monitor's lock before waiting on the inner one, and then re-acquiring both locks upon waking. This strategy ensures deadlock freedom by imposing an order on lock acquisition, specifically, always acquiring M one before M two and never vice versa. However, a critical requirement is that when a nested wait occurs, the programmer must meticulously restore the monitor invariant not only for the outer monitor but also for any subroutine that might be called indirectly.

The section then transitions to Java monitors, highlighting that they remain a core feature, albeit in a simplified form. Java monitors inherently combine scope-based critical sections with condition variables. Implicitly, each object in Java serves as a mutex lock. A critical section is demarcated by a synchronized block that names the object serving as the lock. For instance, the syntax synchronized, followed by the object name in parentheses, denotes a critical section associated with that object instance, ensuring that only one thread can execute within this block at a time.

The concept of a synchronized method is introduced as syntactic sugar. When a class method is declared as synchronized, its execution body behaves as if it were enclosed within a synchronized block that locks on the object itself. This effectively makes all methods of such a class synchronized functions, functioning as monitors. Within a synchronized method or block, a thread can cause its own suspension by invoking the wait method. This method releases the lock on the object, allowing other threads to enter the critical section. A thread can then re-acquire the lock and resume execution after being signaled. To wake up a waiting thread, the notify method is used, which signals a single waiting thread. If multiple threads are waiting on the same condition associated with an object, one must either restructure the code to use separate condition variables for each thread or employ a single condition variable to manage all waiting threads, using notifyAll to wake up all waiting threads.

C sharp provides mechanisms akin to Java's core threading primitives, supporting wait, pulse, and pulseAll operations. The Java five revision introduced an enhanced, library-based interface for monitor management via the Lock class, which offers explicit lock acquisition and release operations. This system is also compatible with scope-based critical sections. Locks offer greater flexibility, enabling arbitrary numbers of associated condition variables, thereby mitigating issues associated with the limitations of single condition variables. Unfortunately, the library-based interface makes programs somewhat awkward, as there is no equivalent of the synchronized label on methods, and the Lock-based equivalent of a synchronized block requires explicit lock and unlock calls within a try-finally block.

The C sharp standard library also provides more general synchronization mechanisms, via its WaitHandle objects, but these are operating-system specific and may behave differently on different systems. The discussion then moves on to other language mechanisms, specifically conditional critical regions. In section one point two, condition synchronization was introduced in the form of a hypothetical await condition statement. One potential complaint with both semaphores and monitors is that they require explicit variables as stand-ins for Boolean conditions. This observation led Brinch Hansen in nineteen seventy-three to propose a notation, the conditional critical region, in which awaited conditions could be specified directly.

Critical conditional regions appear in several languages, including Edison and Ada ninety-five. Syntax is generally some variant on region protected variable when condition, followed by the critical section. As in a Java synchronized block, the protected variable specifies an object whose implicit lock is to be acquired. Some languages allow the programmer to specify a list of objects, in which case their locks are acquired in some canonical order to avoid deadlock. Significantly, the when clause, also known as a guard, can appear only at the beginning of the critical section. The intent is that the enclosed code execute atomically at some point in time where the specified condition is true. This convention avoids the issue of monitor signal semantics but leaves the issue of nested calls.

Figure seven point four uses conditional critical sections to implement a bounded buffer. The code is arguably more natural than the semaphore or monitor versions but raises a crucial implementation question: when and how are the guards evaluated? This highlights the importance of understanding the nuances of conditional critical regions and their implementation in various programming languages.
