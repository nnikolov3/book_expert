Nine point two Hardware T M. Two hundred seven. Hardware S O Codesign. In hardware assisted T M, atomicity remains a program level property, built on multiple non atomic hardware level operations. To maximize performance, one would presumably prefer to implement atomicity entirely in hardware. If hardware transactions are sometimes unsuccessful for reasons other than conflicts, and if fallback to a global lock is not considered acceptable, the challenge then becomes to devise a fallback mechanism that interoperates correctly with hardware transactions. One possible approach is to design the hardware and software together. Kumar et al. two thousand six propose an H T M to complement the object cloning D S T M of Herlihy et al. two thousand three b. Baugh et al. two thousand eight assume the availability of fine grain memory protection, which they use in software transactions to force aborts in conflicting hardware transactions. A more common approach assumes that the hardware is given, and designs software to go with it.

Best Effort Hybrid T M. An H T M implementation is termed best effort if it makes no guarantees of completion, even in the absence of conflicts, and makes no assumptions about the nature of software transactions that might be running concurrently. All of the commercial H T M systems discussed in Section Nine point two point one, with the exception of constrained transactions in T M, fit this characterization. If spurious aborts are common enough to make fallback to a global lock unattractive, one is faced with a generalization of the problem that arose in that simpler case. How do we ensure mutual isolation between the hardware and software code paths? In Section Nine point two point two, we arranged for each hardware transaction to subscribe to the fallback lock, either at the beginning of the transaction or with sandboxing, at the end. This arrangement ensured that a hardware transaction would always abort when a software transaction, implemented as a critical section, which could not itself abort, was active. For hybrid T M, we should like to do better, to enable significant concurrency not only among non conflicting hardware transactions but also with respect to concurrent software transactions.

A hardware transaction, of course, will abort automatically if a concurrent software transaction writes, either eagerly or at commit time, a location that the hardware has written or read. But this is not enough. If a hardware transaction H executes in the middle of software transaction S, perhaps when S is stalled, then H may see inconsistent state. Conversely, H may perform writes that subsequently cause S to see inconsistent state. We must detect such conflicts. Perhaps the most straightforward solution, suggested by Damron et al. two thousand six, is to add extra instructions to the code of hardware transactions, so they inspect and update software metadata. Hardware transactions can then determine whether reads are mutually compatible, and software transactions can validate as they would in an all software system. Unfortunately, while hardware transactions need not re validate at commit time, as software transactions must, the metadata operations they still must perform have significant run time cost.

Vallejo et al. two thousand eleven move much of this instrumentation inside if hardware transaction conditions, thereby reducing the overhead when calling shared routines from nontransactional code. For object oriented languages, Tabba et al. two thousand nine show how instrumented hardware transactions can safely make in place updates to objects that are cloned by software transactions. To obviate instrumentation on the hardware path entirely, Lev et al. two thousand seven suggest switching between hardware and software phases on a global basis, so the two types of transactions never run concurrently. Performance can be excellent, but also somewhat brittle, unless software phases are rare, global phase changes can introduce significant delays. Arguably the most appealing approach to best effort hybrid T M is to employ an S T M algorithm that can detect the execution of concurrent hardware transactions without the need to instrument H T M loads and stores. Dalessandro et al. two thousand eleven achieve this goal by using N Orec on the software path, to leverage value based validation. Hardware transactions must still subscribe to the global N Orec sequence lock, ensuring that they will abort if a software transaction is currently in its commit phase.

Significantly, however, the scalability limitation imposed by N Orecâ€™s serial write back is mitigated in the hybrid version by counting on most transactions to finish in hardware, S T M is only a fallback. In addition, if the hardware supports nontransactional loads within transactions, the compiler can use these to implement safe and precise sandboxing, enabling lazy subscription without false conflicts. Riegel et al. two thousand eleven suggest an alternative approach that relies on nontransactional read and F A I instructions. Matveev and Shavit two thousand thirteen propose a three level system that avoids both the need for nontransactional instructions and, when many transactions fail to commit in hardware, the potential scalability problems of Hybrid N Orec. Their approach is named for the middle level, reduced hardware transactions. In this middle level, the bulk of the transaction is executed in software, building read and write sets using an algorithm like T L two or Tiny S T M. The reads are then validated, and the writes effected in a single hardware transaction whose memory footprint is likely to be much smaller than that of the transaction as a whole and whose instruction stream is almost certain to be free of anything that would deterministically abort best effort H T M.

In the rare event that a middle level transaction fails to commit, its thread reverts to a third level, all software code path that precludes concurrent execution of hardware transactions. Top and middle level transactions must update the performance version numbers that all software transactions use for conflict detection, but they do not need to instrument loads, because all software transactions are rare, top and middle level transactions can simply read a global count of committed software transactions, secure in the knowledge that they will abort if such a transaction has been active. Nine point three Challenges. To serve its original purpose, to facilitate the construction of small, self contained concurrent data structures, T M need not be exposed at the programming language level. Much of the appeal of T M, however, is its potential to help those programmers write parallel code that is both correct and scalable. To realize this potential, T M must be integrated into language semantics and implementations. In this final section of the monograph, we discuss some of the issues involved in this integration. Note that the discussion raises more questions than it answers, thirty years after its original conception, language support for T M is still a work in progress.

Nine point three point one Semantics. The most basic open question for T M semantics is what am I allowed to do inside? Some operations, interactive I O in particular, are incompatible with speculation. We cannot tell the human user please forget I asked you that. Rollback of other operations, many system calls among them, may be so difficult as to force a nonspeculative implementation. The two most obvious strategies for such irreversible, or unrevocable, operations are to simply disallow them in transactions, or force a transaction that performs them to become inevitable, I E, guaranteed to commit. While Spear et al. two thousand eight b have shown that inevitability does not always necessitate mutual exclusion, it nonetheless imposes severe constraints on scalability. In its role as a synchronization mechanism, language level T M must be integrated into the language memory model. Some researchers have argued that since locks already form the basis of many memory models, the behavior of transactions should be defined in terms of implicit locking. Others have suggested that transactions should be defined along with locks and other synchronization primitives, in a co equal fashion, all varieties of synchronization will then contribute to a program's ordering.

This approach was taken by the developers of the two thousand fourteen technical specification, draft feature set, for transactional memory in C plus plus, based on an earlier proposal from Intel, Oracle, I B M, and Red Hat. As of two thousand twenty three, a simpler version of that specification is under consideration for inclusion in C plus plus twenty six. At the same time, given that T M is often promoted as a higher level, more intuitive alternative to locks, there is something conceptually unsatisfying about defining transactional behavior in terms of, or even in concert with, the thing it is supposed to replace. Clearly any language that allows transactions and locks in the same program must explain how the two interact. Considering that locks are typically implemented using lower level atomic operations like C A S, a potentially appealing approach is to turn the tables, as it were, and define locks in terms of atomic blocks. In the framework of section three point three, a global total order on transactions provides a trivial synchronization order, which combines with program order to yield the overall notion of happens before. In the resulting framework, the relationship between transactions and locks is clarified, providing a foundation for understanding how these synchronization primitives interact in concurrent systems.
