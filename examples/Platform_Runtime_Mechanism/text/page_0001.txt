1. Introduction

1.1 Background on System Mangement Mode (SMM)

System Management Mode (SMM) is an operating mode in the x86 computer architecture.
SMM code is written within the context of the system firmware and typically used for system-
wide functions which are highly platform and silicon specific. Some examples would be RAS
(e.g. Hardware Errors such as memory ECC, or to take corrective hardware actions to extend
system uptime), power management, execution of OEM proprietary code, platform hardware
events and implementation of hardware workarounds.

In order to enter SMM, a System Management Interrupt (SMI) must be generated by a platform
events. SMI is a high priority, non-maskable, broadcast interrupt. On receipt of this interrupt, the
processors in the system save their context in SMRAM and transition to SMM to execute the
corresponding SMI Handler for the given event.

The SMI handler code then sets up its own environment (page tables, IDTs etc.), identifies the
source of SMI and handles that event accordingly. The SMI handler is placed by the platform
BIOS during BOOT to a special area of memory called System Management RAM (SMRAM).

SMRAM is invisible to OS/VMM. A processor executing in the 0-3 ring privilege levels will not be
able to read from or write to SMRAM space. When the processor switches to SMM on receipt of
an SMI, then processor executes code out of the SMRAM area.

There are two different categories of SMI sources, asynchronous and synchronous. SMIs due to
platform and hardware events are asynchronous in nature. Software SMls are invoked by
writing to Port 0xB2 (in Intel® Architecture platforms) and are synchronous in nature.

The document describes the Platform Runtime Mechanism (PRM) as a means to remove usage
of certain classes of SMI handlers. PRM, along with Native OS drivers and offload to other
hardware engines such as a Baseboard Management Controller (BMC) offer a path to eliminate
runtime SMis.

1.2 Issues with SMM - Problem Statement
As described in the previous section, SMM mode of operation has the following key attributes:
1. SMRAM (a memory space where SMI Handlers reside) is a Black Box to OS/VMM.
2. SMI Handlers run with their own page tables and accessibility to all system resources
(higher privileged than ring-0).
3. SMI is non-maskable, broadcast and opaque to the OS/VMM.
4. Once in SMM Mode, all other interrupts are pended.

1.2.1 SMI and Perf/QoS degradation

SMI is a global / broadcast event which stalls all system processors. On receipt of a SMI, all the
CPU threads in the system enter SMM mode immediately after completing their current
instruction. This leads to unpredictable performance jitters.

Once inside the SMM environment threads are not available for OS use, and their execution is
stalled until the SMI handler relinquishes control back to the previously executing context. The
amount of execution time in SMM is called SMM Latency. In a typical 4-socket (4S) server class
Introduction.

Background on System Management Mode.
System Management Mode, or S M M, is an operating mode in the x eight six computer architecture. S M M code is written within the context of the system firmware and typically used for system wide functions which are highly platform and silicon specific. Some examples would be R A S, such as hardware errors like memory E C C, or to take corrective hardware actions to extend system uptime, power management, execution of O E M proprietary code, platform hardware events, and implementation of hardware workarounds.

In order to enter S M M, a System Management Interrupt, or S M I, must be generated by a platform event. S M I is a high priority, non maskable, broadcast interrupt. On receipt of this interrupt, the processors in the system save their context in S M Ram and transition to S M M to execute the corresponding S M I Handler for the given event.

The S M I handler code then sets up its own environment, including page tables, I D T s, and identifies the source of S M I and handles that event accordingly. The S M I handler is placed by the platform B I O S during boot to a special area of memory called System Management Ram, or S M Ram.

S M Ram is invisible to O S or V M M. A processor executing in the zero to three ring privilege levels will not be able to read from or write to S M Ram space. When the processor switches to S M M on receipt of an S M I, then the processor executes code out of the S M Ram area.

There are two different categories of S M I sources, asynchronous and synchronous. S M I s due to platform and hardware events are asynchronous in nature. Software S M I s are invoked by writing to Port hexadecimal zero x B two, in I N T E L Architecture platforms, and are synchronous in nature.

The document describes the Platform Runtime Mechanism, or P R M, as a means to remove usage of certain classes of S M I handlers. P R M, along with Native O S drivers and offload to other hardware engines such as a Baseboard Management Controller, or B M C, offer a path to eliminate runtime S M I s.

Issues with S M M – Problem Statement.
As described in the previous section, S M M mode of operation has the following key attributes. First, S M Ram, which is a memory space where S M I Handlers reside, is a Black Box to the O S or V M M. Second, S M I Handlers run with their own page tables and accessibility to all system resources, being higher privileged than ring zero. Third, S M I is non maskable, broadcast, and opaque to the O S or V M M. Fourth, once in S M M Mode, all other interrupts are pended.

S M I and Performance or Q O S degradation.
S M I is a global broadcast event which stalls all system processors. On receipt of an S M I, all the C P U threads in the system enter S M M mode immediately after completing their current instruction. This leads to unpredictable performance jitters.

Once inside the S M M environment, threads are not available for O S use, and their execution is stalled until the S M I handler relinquishes control back to the previously executing context. The amount of execution time in S M M is called S M M Latency. In a typical four socket server class.
System Management Mode, or S M M, represents a highly privileged operating environment within the X eighty six computer architecture. Its primary design purpose is to enable the system firmware, typically the B I O S or U E F I, to execute platform specific functions that operate beneath the visibility and control of the operating system or hypervisor. Examples of functions entrusted to S M M include critical system reliability, availability, and serviceability tasks, such as handling memory Error Correcting Code errors, managing power states, executing proprietary O E M diagnostics, or implementing hardware workarounds for silicon errata. This mode is critical because it provides a mechanism for deep system management that is entirely transparent to higher level software.

Entry into S M M is orchestrated by a System Management Interrupt, or S M I. An S M I is a fundamentally distinct type of interrupt, characterized by its high priority, non maskable nature, and broadcast delivery mechanism, meaning it impacts all processors simultaneously. Upon receipt of an S M I, each processor in the system immediately saves its current operational context, including registers and execution state, into a specially designated area of memory known as System Management Ram, or S M Ram. Following this context save, the processor transitions into S M M to execute the corresponding S M I handler.

The S M I handler code is responsible for setting up its own execution environment, including its unique page tables and interrupt descriptor tables, to manage memory and interrupts independently from the main O S. It then proceeds to identify the specific source of the S M I and address the underlying event. The crucial aspect here is that the S M I handler code is pre loaded into S M Ram by the platform B I O S during the system boot sequence, establishing a fixed and isolated environment for these critical operations.

System Management Ram itself is a cornerstone of S M M's security and isolation model. It is designed to be completely invisible and inaccessible to software running at lower privilege levels, specifically from ring zero through three, which encompass the operating system kernel and user applications. This isolation ensures that the S M M code, which operates at a privilege level higher than the O S, cannot be tampered with by less privileged software. The processor directly executes instructions from within this S M Ram area when operating in S M M.

S M Is can be broadly categorized into two types: asynchronous and synchronous. Asynchronous S M Is are triggered by external platform or hardware events, such as a hardware error condition or a specific I O port write, for example, a write to Port hexadecimal B two on certain architectures. Synchronous S M Is, conversely, are initiated by software, typically by specific instructions or internal processor events.

Recognizing the inherent complexities and performance implications of S M M, some contemporary system designs incorporate mechanisms like the Platform Runtime Mechanism, or P R M. P R M aims to reduce or eliminate the reliance on S M M for certain classes of S M I handlers by offloading their responsibilities to other system components, such as native O S drivers or a Baseboard Management Controller, or B M C. This architectural shift seeks to mitigate the challenges associated with S M M by moving functionality out of this highly privileged and disruptive mode.

Despite its necessity for fundamental system operations, S M M presents several significant technical challenges and problematic attributes. First, S M Ram's invisibility to the O S and V M M renders it a "Black Box," preventing higher level software from introspecting or directly controlling the operations occurring within S M M. This lack of transparency can complicate debugging and raise security concerns. Second, S M I handlers execute at a privilege level that transcends even ring zero, granting them access to all system resources and the ability to operate with their own independent memory management context, including dedicated page tables. This supreme privilege means an S M M handler can potentially bypass all O S and V M M security measures. Third, the non maskable, broadcast, and opaque nature of an S M I means it cannot be ignored by any processor, it halts all processors, and its internal operations are not exposed. Fourth, once a system enters S M M, all other pending interrupts are deferred until the S M M handler completes, leading to potential system unresponsiveness.

The most profound impact of S M M, particularly in high performance and real time systems, lies in its effect on system performance and Quality of Service, or Q o S. An S M I is a global, broadcast event that effectively stalls all processors in the system. Upon receiving an S M I, every C P U thread in the system is forced to immediately suspend its current operation after completing the instruction it is executing and transition into S M M. This immediate and system wide halt results in unpredictable performance jitters and latency, which can be detrimental to applications requiring consistent execution timings or low latency responses. Furthermore, during the execution of an S M M handler, the C P U threads and resources allocated to the S M M environment are unavailable for use by the O S, effectively blocking the operating system's normal execution. The duration for which the processor remains within S M M, waiting for the handler to relinquish control back to the previously executing context, is defined as S M M Latency. In complex, multi socket server class systems, even a brief S M M Latency can translate into significant performance degradation across the entire system.
