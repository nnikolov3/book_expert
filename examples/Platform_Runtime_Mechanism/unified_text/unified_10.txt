The text describes a mechanism within the Advanced Configuration and Power Interface, or A C P I, for enabling communication between the operating system and platform firmware using its source language, A S L, the A C P I Source Language. This interaction is facilitated through a runtime service known as the Platform Runtime Mechanism, or P R M, which allows dynamic invocation of device-specific firmware functions via a standardized interface.At the heart of this system is a Globally Unique Identifier, or G U I D, referred to as the D S M G U I D. This identifier spans from offset ten to offset sixteen within a data structure and is populated by the caller. The D S M G U I D uniquely identifies a Device Specific Method, allowing the operating system to request specific firmware-level operations that are not part of standard hardware abstractions. For the request to be valid, this G U I D must be present in the list of available handlers published by the P R M T table—the Platform Runtime Mechanism Table—which acts as a registry ensuring only authorized and recognized services can be invoked, thus preserving system integrity and security.To manipulate the byte fields within the communication buffer, A S L provides several field creation operators: Create Byte Field, Create Q Word Field, and Create Field. These operators allow structured access to specific regions of a buffer by defining symbolic names for data segments at given offsets. For example, Create Byte Field defines a single byte-sized field, Create Q Word Field defines an eight-byte, or sixty-four-bit, field, and Create Field allows the definition of a field with arbitrary bit length and alignment. By using these constructs, A S L code can read from and write to the buffer using a single store operator, enabling efficient and atomic access to hardware or firmware interfaces.Section eight point two presents an example of how data is written to the P R M data buffer. A control method named R U N S is defined, which takes one argument, Arg zero. This argument is expected to contain a buffer representing the D S M G U I D. Inside the method, a local variable, Local zero, is initialized as a buffer of twenty-six bytes, serving as the communication payload for the P R M service.Within this buffer, several fields are defined. A byte field named P S T A is created at offset hexadecimal zero, likely representing platform status. A Q Word field named U S T A is created at offset hexadecimal one, occupying eight bytes, which may be used to store a large identifier, address, or status code. A byte field named C M D is created at offset hexadecimal nine to hold a command code. Finally, a field named D A T A is defined starting at offset hexadecimal fifty with a length of hexadecimal eighty bits, equivalent to one hundred twenty-eight bits, or sixteen bytes. This field is used to carry the primary data payload.The method then populates the command and data fields. The C M D field is set to zero, indicating a run command, and the D A T A field is assigned the value of Arg zero, effectively passing the D S M G U I D into the payload. To invoke the P R M Operation Region Handler, the contents of Local zero must be written to a designated P R M Operation Region Field Unit. The result from the handler is retrieved by reading the contents of that field unit back into Local zero.An Operation Region named P R M R is defined using the Platform R T Mechanism type, mapped to a hardware or logical address space starting at offset hexadecimal zero with a length of one byte. Within this region, a field named P R M F is defined with a bit length of eight, accessed using Buffer Access mode, with No Lock synchronization and a Preserve write policy. This means that when the field is written, its previous content is preserved unless explicitly overwritten, and no internal locking is applied, implying that external synchronization is managed by the caller or firmware.The invocation of the handler is performed by the statement Local zero equals the result of P R M F being assigned Local zero. This expression writes the Local zero buffer to the P R M F field, triggering the firmware handler to process the request. Upon completion, the handler writes the response back into the same buffer space, which is then read back into Local zero. After this operation, the P S T A and U S T A fields contain the status results. If P S T A is not true, indicating a failure at the platform level, an error handling routine is executed. Similarly, if U S T A is not true, an optional user-level status check is performed. The method concludes by returning the value of P S T A, indicating the overall success or failure of the operation.Section eight point two point one provides an example of locking a P R M transaction. A method named L O C K is defined, also taking one argument, Arg zero, which contains the D S M G U I D. Inside the method, Local zero is initialized as a twenty-six-byte buffer. Fields are defined over this buffer: a byte field named S T A T at offset hexadecimal zero, a byte field named C M D at offset hexadecimal nine, and a field named G U I D starting at offset hexadecimal fifty with a length of hexadecimal eighty bits.The C M D field is set to one, representing a lock command, and the G U I D field is populated with the value from Arg zero. The method then invokes the P R M F handler by assigning Local zero to P R M F and simultaneously capturing the result back into Local zero. The S T A T field now contains the return status of the lock operation. The method returns this status value, allowing the caller to determine whether the lock was successfully acquired.Section eight point two point two describes a method named U L C K, designed to unlock the P R M transaction. This method also takes a single argument, Arg zero, containing the D S M G U I D. Although the body of the method is not fully detailed in the provided text, the implied structure mirrors that of the L O C K and R U N S methods. It would involve initializing Local zero, defining the same field layout, setting the C M D field to a value corresponding to an unlock command—likely two or another designated code—populating the G U I D field with Arg zero, invoking the P R M F handler, and returning the resulting status from the S T A T field.These examples illustrate a structured, low-level protocol for secure and synchronized interaction between the operating system and firmware. The use of G U I Ds enables precise targeting of device-specific services, while the field creation operators provide a high-level abstraction over raw memory, enhancing code clarity and maintainability. The locking and unlocking mechanisms enforce mutual exclusion, ensuring that P R M transactions occur atomically and without interference from concurrent operations. This is essential for maintaining data consistency and system stability when accessing critical platform resources.The overall design reflects a transactional model where each operation is encapsulated in a well-defined buffer, triggered through a standardized interface, and returns status information to enable robust error handling. This layered approach separates the command trigger—handled via the compact P R M F field—from the larger data payload in Local zero, optimizing both performance and modularity. Such patterns are foundational in modern firmware design, particularly in U E F I and B I O S environments, where reliable, secure, and efficient system management is paramount.
