The text describes a set of interrelated data structures and mechanisms used in low level system firmware, particularly within a Platform Runtime Module, or P R M, environment. These structures facilitate communication between firmware components, the operating system, and hardware, enabling secure and efficient management of platform resources during system runtime.At the core is the **P R M Module Information Structure**, which acts as a top level descriptor for a P R M module. This structure begins with versioning fields: **Major Revision**, a two byte field at byte offset twenty, indicates the primary version of the P R M module, reflecting significant changes in functionality or interface. Following it at byte offset twenty two is **Minor Revision**, also two bytes, which captures incremental updates. Together, these fields support compatibility checking and evolution tracking.Next is **Handler Count**, a two byte field at byte offset twenty four, specifying the number of **P R M Handler Information Structure** entries associated with this module. This value determines the size of the subsequent array of handler descriptors. Directly after, at byte offset twenty six, is **Handler Info Offset**, a four byte field that provides the byte offset from the start of the P R M Module Information Structure to the beginning of the first **P R M Handler Information Structure**. This indirection allows flexibility in memory layout, supporting alignment requirements or dynamic placement.At byte offset thirty, the **Runtime M M I O Pages** field occupies eight bytes and holds a physical address pointer to a **P R M underscore R U N T I M E underscore M M I O underscore R A N G E S** structure. This structure contains an array of descriptors defining Memory Mapped I O regions that the P R M module may access during runtime. The operating system is responsible for mapping these physical M M I O ranges into virtual memory and populating the corresponding virtual addresses. If no runtime M M I O access is required, this pointer may be N U L L.Finally, starting at byte offset thirty eight, the **Handler Info Structure** array begins. Its total size is the product of **Handler Count** and the size of each **P R M Handler Info Structure**. Each entry in this array describes an individual P R M handler within the module, providing metadata such as identifier, address, and associated data buffers.Each **P R M Handler Information Structure** is detailed in Table four dash three. It starts with **Structure Revision**, a two byte field at byte offset zero, indicating the version of this descriptor structure. Adjacent to it at byte offset two is **Structure Length**, another two byte field, which specifies the total size in bytes of the entire **P R M Handler Info Structure**. This self describing property enables robust parsing, especially when multiple such structures are present in a stream.At byte offset four, the **Identifier** field spans sixteen bytes and contains a G U I D, or Globally Unique Identifier, that uniquely identifies the P R M handler. This allows the operating system or other components to recognize and dispatch to the correct handler logic based on type or function.At byte offset twenty, the **Physical Address** field, eight bytes in size, holds the physical memory address of the P R M handler's code or entry point. This is used by the system to invoke the handler directly in the firmware execution environment.At byte offset twenty eight, the **Static Data Buffer** field is an eight byte physical address pointer to a dedicated data buffer allocated during the B I O S boot phase. This buffer is intended to hold configuration data such as B I O S setup options, board strap settings, or S o C fuse values, and is populated by the firmware before runtime. A pointer to this buffer is passed to the handler upon invocation. This pointer may be N U L L if no static data is required.Additionally, at byte offset thirty six, the **Acpi Parameter Buffer** field, also eight bytes, holds a physical address pointer to a parameter buffer used exclusively when the handler is invoked via A S L, or A C P I Source Language. This buffer facilitates parameter passing between A S L methods and the P R M handler. Like the static data buffer, it is allocated during the firmware boot environment and may be updated at runtime by A S L code. If A S L invocation is not used or no parameters are needed, this pointer may be N U L L.Section four point two elaborates on the two primary buffer types used by P R M handlers.The **Static Data Buffer**, described in subsection four point two point one, is allocated during the B I O S boot phase. While its contents and size are implementation specific, its header follows a standardized format defined in Table four dash four: **P R M Static Data Buffer Structure**. The header begins with a **Signature** field at byte offset zero, four bytes long, containing the ASCII characters 'P R M S'. This acts as a magic number to validate the buffer's type and integrity. Following it at byte offset four is the **Length** field, also four bytes, which specifies the total size of the buffer, including the header. The actual data payload starts at byte offset eight and varies in length depending on the module's needs. This header design enables safe and reliable parsing of the buffer contents by the handler.Subsection four point two point two covers the **Acpi Parameter Buffer**, which is used only in the A S L invocation path. Its internal format is a contract between the A S L caller and the P R M handler, ensuring consistent interpretation of the data. The structure of this buffer is defined in Table four dash five: **P R M A C P I Data Buffer Structure**. It mirrors the static data buffer in layout: the **Signature** field at byte offset zero contains 'P R M P', identifying it as an A C P I parameter buffer. The **Length** field at byte offset four, four bytes in size, specifies the total buffer size including the header. The **Data** field begins at byte offset eight and contains the variable length payload specific to the P R M module. If no parameter buffer is provided, a N U L L pointer is passed to the handler.Subsection four point two point three addresses **Module Runtime M M I O Ranges**. A P R M module must declare any M M I O regions it intends to access by creating an array of **P R M underscore M O D U L E underscore R U N T I M E underscore M M I O underscore R A N G E** descriptors. A pointer to this array is passed to the handler via the **Runtime M M I O Pages** field. Each descriptor, detailed in Table four dash six, consists of three fields. The **Physical Base Address**, eight bytes at byte offset zero, specifies the starting physical address of the M M I O range. The **Virtual Base Address**, eight bytes at byte offset eight, is populated by the operating system with the corresponding virtual address mapping. This allows the handler to access the hardware through virtual memory once the O S has set up the page tables. The **Length** field, four bytes at byte offset sixteen, specifies the size of the M M I O region in bytes.This cooperative model ensures that the firmware declares its hardware access requirements, while the operating system retains control over virtual memory management, enforcing memory protection and isolation. The separation of physical and virtual addressing reflects modern memory management principles, where hardware resources are abstracted through virtualization for security and flexibility.In summary, these structures form a comprehensive framework for low level system firmware to expose runtime capabilities, manage hardware access, and exchange data with both the operating system and A C P I components. They emphasize versioning, self describing layouts, standardized headers, and clear ownership of responsibilities between firmware and operating system. The use of G U I D s, magic signatures, and length fields enhances robustness, while pointer indirection and variable length payloads provide flexibility. These mechanisms are essential for enabling secure, portable, and maintainable platform runtime services in complex computing environments.
