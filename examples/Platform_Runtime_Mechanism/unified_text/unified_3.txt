Platform Runtime Modules, or P R M, represent a critical class of firmware components designed to extend system functionality directly into the operating system runtime environment. Any platform firmware or B I O S environment that satisfies the necessary technical requirements can utilize P R M, with the Unified Extensible Firmware Interface, U E F I, offering particularly efficient support due to its standardized architecture and minimal overhead.While P R M is not restricted exclusively to U E F I based systems, the U E F I specification inherently supports many of the foundational mechanisms required for P R M operation. This compatibility arises primarily from the presence of U E F I Runtime Services, which provide an industry standard method for firmware to expose executable code during operating system runtime. These services define a stable Application Binary Interface, A B I, ensuring that P R M handlers can be invoked under consistent execution conditions, including guaranteed stack size availability. This standardization eliminates the need for platform-specific workarounds and ensures predictable behavior across diverse hardware implementations.Security is another key aspect addressed by the U E F I framework. The U E F I Secure Boot chain-of-trust mechanism provides a built-in method for authenticating P R M modules that are embedded within the firmware boot image. By cryptographically verifying the integrity and origin of these modules, U E F I Secure Boot helps prevent unauthorized or malicious code from executing in the runtime environment, thereby preserving system security throughout the boot and runtime phases.Additionally, U E F I supports runtime virtual address fixups, a crucial capability for enabling firmware-resident code to operate correctly in an operating system environment where virtual memory management is active. During runtime, drivers and firmware components often need to access memory-mapped I O, or M M I O, regions using virtual addresses rather than physical ones. U E F I firmware includes provisions to map physical addresses to their corresponding virtual addresses, allowing P R M handlers to seamlessly interact with hardware resources even after the operating system has enabled paging and virtual memory.A comparison between U E F I based and non-U E F I boot environments highlights the advantages of the U E F I approach. In U E F I systems, P R M handlers execute during O S runtime and are published by the firmware via U E F I Runtime Services, which serve as a standardized, O S independent interface. In contrast, non-U E F I environments lack such a standard mechanism, requiring custom, implementation-specific solutions to expose runtime code to the operating system. This absence of standardization increases complexity and reduces portability.Regarding chain-of-trust, U E F I Secure Boot offers a well-defined, widely adopted authentication framework. Non-U E F I systems typically do not have an equivalent standardized mechanism, leaving security implementation to individual vendors and often resulting in inconsistent or weaker protection. Similarly, for pointer fixups—necessary for translating physical memory addresses into virtual addresses during O S runtime—U E F I provides built-in support, while non-U E F I platforms must implement this functionality ad hoc, if at all.Furthermore, P R M implementations in U E F I environments are inherently O S independent, meaning they can function across different operating systems without modification. In non-U E F I contexts, support is generally implementation specific, tightly coupling the firmware interface to a particular operating system and limiting flexibility.The process of loading and invoking P R M modules follows a structured sequence during system initialization. First, during the pre-operating system boot phase, the firmware scans its flash memory image to discover all P R M modules included in the platform firmware. Once identified, the firmware constructs and publishes the P R M A C P I table, known as the P R M T, which serves as a central descriptor for all available P R M components. This table provides detailed information about each module, including its handlers and associated data structures such as context buffers.Concurrently, the firmware allocates any required memory buffers needed for P R M operation. In some cases, such as with static data buffers, the firmware also initializes the contents of these buffers during boot. This pre-allocation ensures that when the operating system later invokes a P R M handler, all necessary resources are already in place and properly configured.Once the operating system is running, it can invoke P R M handlers through one of two primary mechanisms: direct function calls or Device Specific Methods, D S M. The choice of mechanism depends on the specific use case and the level of abstraction required. Direct calls offer low-latency access to handler functionality, while D S Ms provide a more flexible, scriptable interface through A C P I Source Language, or A S L, code.At the core of this interaction is the P R M T table, an A C P I compliant structure published by the B I O S during boot. This table acts as a discovery and advertisement mechanism, exposing pointers to all P R M handlers so that the operating system can locate and invoke them as needed. The A C P I Interpreter, a component within the operating system kernel, parses the P R M T and uses its contents to route invocations to the appropriate handler. The table is designed with a hierarchical layout, enabling logical organization of complex platform services and facilitating extensibility.Each P R M module encapsulates a set of related handlers centered around a specific platform feature. For example, a Reliability, Availability, and Serviceability, or R A S, module might include handlers for error logging and system diagnostics, while a Non Volatile D Ram, or N V D I M M, module could provide functions for managing persistent memory devices. The P R M T table begins with a standard A C P I header, which includes fields such as Signature, Length, Revision, and Checksum to ensure proper identification and data integrity.The Signature field contains the four-character identifier 'P R M T', allowing the operating system to recognize the table type. The Length field specifies the total size of the table in bytes, enabling correct memory allocation and parsing. The Revision field, set to zero for this version, indicates the current schema version. The Checksum field, computed over the entire table, allows the operating system to verify that the table has not been corrupted during transmission or loading.Following the standard header are identification fields: O E M I D, O E M Table I D, and O E M Revision, which uniquely identify the manufacturer and version of the table. The Creator I D and Creator Revision fields specify the tool or utility that generated the table, aiding in debugging and compatibility assessment.A sixteen-byte field named P R M Platform G U I D provides a unique identifier for the platform itself. This G U I D assists operating system power management, or O S P M, components in targeting specific platforms for runtime updates or feature enablement. While some O S P Ms may use proprietary mechanisms for platform identification, this field offers a standardized alternative.Two critical fields—P R M Module Info Offset and P R M Module Info Count—define the location and number of P R M Module Information structures within the table. The offset specifies the byte distance from the start of the P R M T to the beginning of the first module entry, while the count indicates how many such entries exist. Together, they define a variable-length array of P R M Module Information structures, each describing a distinct P R M module on the platform.Each P R M Module Information Structure contains metadata about a single module. It begins with a two-byte Structure Revision field, indicating the version of this structure format, followed by a two-byte Structure Length field, which specifies the total size of the structure, including any embedded arrays of handler information. This length enables the operating system to correctly traverse the array of module entries.The Identifier field, sixteen bytes in size, holds a G U I D that uniquely identifies the P R M module. This allows the operating system to distinguish between different modules and manage them independently.Within each module structure is an array of P R M Handler Info Structures, the number of which is specified by the P R M Handler Count field. Each Handler Info Structure includes its own revision and length fields, a G U I D that uniquely identifies the handler, a pointer to the executable handler code, and an optional pointer to an A C P I Parameter Buffer.The pointer to the handler provides the entry point for execution, while the optional parameter buffer serves as a shared memory region for passing data between the invoker—such as A S L code—and the handler. The format of the data within this buffer is governed by a contractual agreement between the two parties. For direct invocation scenarios, the invoker is responsible for allocating and populating this buffer, providing flexibility in how arguments are prepared.Additionally, each P R M Module Structure includes a pointer to runtime M M I O Ranges, which refer to memory-mapped I O regions used by the handlers to communicate directly with hardware. These ranges allow the handlers to read from and write to device registers, enabling low-level control and monitoring of platform components.In summary, the P R M T table provides a robust, hierarchical, and extensible framework for exposing platform runtime services to the operating system. By leveraging standardized A C P I mechanisms, G U I D based identification, and pointer-based linking to code and data, it enables secure, efficient, and O S independent interaction between firmware and the operating system, supporting advanced system management, diagnostics, and hardware control throughout the system lifecycle.
