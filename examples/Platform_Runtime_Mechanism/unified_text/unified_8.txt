Seven. Servicable P R M.Over time, a Platform Runtime Mechanism handler, or P R M handler, may require updates for various reasons, including bug fixes, workarounds for hardware or software anomalies, or to enhance the system's runtime capabilities and feature set. These updates are applied at the module level, meaning that it is not possible to update an individual handler in isolation. Any modification necessitates updating the entire P R M Module. Consequently, versioning for P R M components is managed at the module level. Traditionally, such firmware updates would require a system reboot, allowing the new firmware code to be loaded during the next boot sequence from non volatile storage into the system's memory.However, in modern cloud services environments, system reboots are highly disruptive and are avoided whenever possible. Reboots introduce service downtime, complicate orchestration, and degrade availability. Therefore, a mechanism is required to update P R M modules dynamically during operating system runtime, without requiring a system restart.This document outlines a generic framework to enable such runtime updates by extending the Advanced Configuration and Power Interface, or A C P I, Bridge driver with the capability to switch to a new P R M Module image while the system remains operational.Seven point one. High Level Flows.When a new P R M Module update is required, the system B I O S build process generates a new module image, as described in Section six, or retrieves an O S specific format from a designated repository. The generation and delivery of this image are implementation specific and fall outside the scope of this specification.During O S runtime, an O S updater consumes the newly delivered P R M Module. The process proceeds in three main steps. First, the updater parses the P E slash C O F F Export Descriptor structure embedded in the module. This parsing serves two purposes: to confirm that the binary is a valid P R M Module, and to verify that it targets the correct platform. Platform targeting is achieved by matching the P R M Platform G U I D in the module to the PrmPlatformGuid field in the P R M T Table. Some implementations may instead use the E S R T mechanism or another proprietary method for platform validation.Second, the updater loads the P R M module into system memory, typically D Ram, and performs necessary fix ups. These fix ups include address relocation, symbol resolution, and pointer patching to ensure the module integrates correctly into the current runtime memory layout.Third, the updater sends a request to the A C P I Subsystem to update its internal pointers to the P R M handlers, so that subsequent invocations are directed to the new module.Upon receiving this request, the A C P I Subsystem performs a series of checks. First, it determines whether updates are currently locked or allowed. If updates are locked, the new P R M image is staged—held in memory but not activated—until the lock is released. If updates are unlocked, the A C P I Subsystem atomically switches the handler pointers to the new P R M Module, effectively activating the update without interrupting system operation.Seven point one point one. Update Lock slash Unlock.Most P R M Handler invocations are stateless, meaning they do not maintain internal state between calls. This allows updates to be applied between individual invocations. However, certain operations require a sequence of P R M invocations that must complete as an atomic unit. In such cases, a runtime update to the P R M Module must be blocked until the sequence is complete to prevent inconsistencies or failures.An example of such a sequence is Address Range Scrub, or A R S, for persistent memory, as defined in the N V D I M M D S M Interface specification. A R S is a long latency operation involving multiple steps, each implemented as a D S M call that invokes a corresponding P R M Handler.The A R S operation consists of three primary functions:First, Query A R S Capabilities, using Function Index one.Second, Start A R S, using Function Index two.Third, Get A R S Status, using Function Index three.The P M E M Driver initiates the sequence by calling Query A R S Capabilities to determine supported features, then invokes Start A R S to begin the scrubbing process. Since A R S may take a significant amount of time, Start A R S returns immediately after initiating the background task. The driver then periodically polls for completion by calling Get A R S Status.Each of these D S M functions triggers a corresponding P R M Handler. If a P R M Module update were to occur mid sequence, the handlers could be replaced while the operation is in progress, leading to undefined behavior or data corruption.To prevent this, a Lock slash Unlock mechanism is provided as part of the A C P I subsystem. This mechanism is detailed in Section eight point one point two and Table eight one.A D S M Method that initiates a multi step sequence must first invoke a Lock request, as defined in Section eight point two point one, before executing the sequence. At the end of the sequence, it must invoke an Unlock request, as defined in Section eight point two point two.In the A R S example:First, after Query A R S Capabilities is invoked, the A S L code issues a Lock request by passing the P R M Handler G U I D, which corresponds to the D S M U U I D. The A C P I Interpreter identifies the associated P R M Module and locks it, preventing any update from taking effect. Importantly, the P R M Handler itself is not invoked during the Lock operation.Second, any update request received by A C P I while the module is locked is staged but not activated.Third, once the Get A R S Status call returns indicating that the A R S operation is complete, the A S L code invokes the Unlock method, passing the same G U I D. The A C P I Interpreter then unlocks the module, allowing future updates to proceed.If a previous update was staged during the lock period, the A C P I Subsystem may choose to switch to the staged P R M Module at the moment of unlock, completing the update in a safe and atomic manner.The responsibility for invoking Lock and Unlock rests with the entity initiating the sequence—either the D S M method in A S L code or an O S driver in the case of direct invocation. This entity has the necessary context to determine whether the operation is part of a multi step sequence or a standalone, stateless call.An operating system may choose not to support runtime P R M updates at all, relying solely on firmware updates during reboots. Alternatively, it may implement a robust framework to support live updates and minimize downtime. Since this decision is O S specific, the specification does not define a universal implementation. However, the runtime update process in Microsoft Windows is described as a concrete example.Seven point two. Installation in Windows.In the Windows operating system, the runtime update process follows a structured approach.First, during O S runtime, an O S owned updater validates the new P R M Module image for authenticity and integrity. Once validated, it writes the module to a well known location on disk. For example, in Windows, this location is typically `system thirty two backslash P R M backslash modules backslash left curly brace G U I D right curly brace`.Second, the updater parses metadata from the module and persists the following information to the system registry, ensuring it survives reboots:One, the full file path of the P R M module.Two, the module version number.Three, the list of P R M handler G U I D s contained within the module.Third, the updater loads the module into memory, performs fix ups, and sends a request to A C P I to update its handler pointers to the new module.Seven point two point one. Persisting P R M Module Updates Across Reboot slash K S R.After a system reboot or Kernel State Restore, the Windows boot loader, known as winload, reads the system hive from the registry. It checks whether any P R M module updates have been applied beyond the firmware's original base image.For each updated module, winload loads the latest version—determined by the version number stored in the registry—from the on disk location into memory. It then adds the module to the boot start driver list, a mechanism already used for early loaded kernel drivers.This approach leverages existing Memory Manager, or M M, support for relocating drivers in memory, ensuring compatibility with the system's boot time loading infrastructure.After the kernel initializes, the A C P I dot sys driver reinitializes. It reads the loader block, which contains information about the loaded P R M modules, and reconstructs an up to date view of the available P R M handlers.For both cold boot and K S R scenarios, the A C P I interpreter is paused until all P R M updates have been processed. This ensures that no P R M invocations occur with stale or inconsistent handler pointers, maintaining system stability during the critical early boot phase.Seven point three. Rollback.It is essential that platforms supporting P R M functionality provide a rollback mechanism in case an update causes instability or incompatibility. This requirement is analogous to the rollback capability now standard for microcode updates.To simplify the update model, rollback is treated not as a reversal, but as a forward update to a prior known good version. This is accomplished by incrementing the module version number to designate a previous, stable version. Each rollback is thus a new update that reverts behavior to an earlier state, ensuring that all versions are managed uniformly within the versioning system.A diagram titled P R M Module Versioning Update Example illustrates this progression. It shows three states of Module one, labeled Version one, Version two, and Version three. Each version contains the same set of handlers: Handler one, Handler two, and Handler three. Arrows connect the versions sequentially, indicating the flow of updates. The diagram emphasizes that while the module version advances, the exposed handlers remain consistent, supporting API stability and backward compatibility.A critical consideration in rollback scenarios is hardware state. The model assumes that hardware behavior is stateless with respect to P R M updates. However, in practice, a P R M update might set reserved bits in hardware registers, altering the hardware's configuration. If a rollback is performed—such as moving from Version three back to Version two—the system must ensure that any such hardware bits are either reset to a known good state or that their presence does not interfere with the operation of the older P R M Module.This highlights the need for careful design at the hardware software interface. Down level P R M modules must be able to function correctly even if hardware state reflects configurations established by newer versions, ensuring system resilience during version transitions.
