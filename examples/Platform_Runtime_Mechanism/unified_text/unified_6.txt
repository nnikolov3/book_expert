The Platform Runtime Management, or P R M, Module Context Buffer is a structured data container used to convey configuration and operational parameters from the operating system to firmware-level handlers during runtime. This buffer is essential for enabling secure and efficient communication between the O S and platform-specific management code, ensuring that the necessary contextual information is available when executing low-level operations.The structure begins with the Revision field, which occupies two bytes at offset zero and is intended to expand to four bytes in future implementations. This field indicates the version of the P R M Module Context Buffer structure itself, allowing for backward and forward compatibility as the specification evolves. A higher revision number signals the presence of additional or modified fields, enabling the system to interpret the buffer correctly based on its version.Following this is the Reserved field, which currently uses two bytes starting at offset two, with a planned expansion to six bytes. This field is reserved for future use or for alignment purposes, ensuring that subsequent fields are properly aligned in memory according to architectural requirements. It must be ignored by software implementations and may be zero-initialized.At offset four, the Identifier field spans sixteen bytes and contains a Globally Unique Identifier, or G U I D, that uniquely identifies the P R M handler associated with this context buffer. This G U I D serves as a key for routing and dispatching operations to the correct handler implementation. Although the current size is sixteen bytes, the target size is eight bytes, suggesting a potential future optimization or reinterpretation of this field, possibly as a pointer or truncated identifier.Next is the StaticDataBuffer field, located at offset twenty, occupying eight bytes. This field is a virtual address pointer labeled as P R M underscore D A T A underscore B U F F E R, pointing to a static data buffer allocated for the P R M handler. This buffer is intended to be populated during the firmware boot environment, prior to O S runtime, and contains configuration data that remains constant throughout execution. The use of a virtual address implies that memory management is active when this pointer is accessed, requiring translation via the Memory Management Unit. If no static data is required, this pointer may be N U L L, and P R M handler code must be designed to check for and handle this condition gracefully.At offset twenty eight, the RuntimeMmioRanges field occupies another eight bytes and is labeled P R M underscore M O D U L E underscore C O N F I G underscore R U N T I M underscore M M I O underscore R A N G E S. This is a virtual address pointer to an array of P R M runtime M M I O range structures. Each structure describes a Memory Mapped I O, or M M I O, physical address range that has been mapped into virtual memory for access during O S runtime. These mappings allow the P R M handler to directly interact with hardware registers and device memory without relying on traditional I O port instructions. Like the StaticDataBuffer, this pointer is set during the firmware boot environment and may be N U L L if no runtime M M I O access is needed. The handler must validate this pointer before dereferencing it.The total size of the Context Buffer is forty bytes in its current form, with potential future expansion to accommodate larger fields. This buffer is allocated and constructed by the O S Bridge Driver, which retrieves the necessary information from the P R M T, or Platform Runtime Management Table, an A C P I defined table that describes available P R M modules and their associated resources. Specifically, the Bridge Driver uses the StaticDataBuffer and RuntimeMmioPages entries from the P R M T to populate the corresponding pointers in the Context Buffer. If any of these entries are absent or invalid in the A C P I table, the Bridge Driver passes a N U L L pointer to the P R M handler. Therefore, robust P R M handler implementations must include null pointer checks and alternative execution paths to ensure reliability under all conditions.Figure five dash one illustrates the invocation model for P R M handlers. It shows two primary pathways by which an O S Driver, such as a R A S Handler for Reliability, Availability, and Serviceability, can trigger a P R M operation.The first path is labeled Invocation through A C P I. In this scenario, the O S Driver calls an A C P I underscore D S M, or Device Specific Method, which is a vendor-defined A C P I function. This method then invokes a P R M Operation Region, passing a G U I D to identify the target handler and a pointer to a parameter buffer containing input data. A red cross over the S M I, or System Management Interrupt, path indicates that this invocation mechanism explicitly avoids entering System Management Mode. This design choice enhances transparency and reduces latency, as S M I handlers operate in a privileged, opaque environment that can interfere with O S scheduling and debugging.The second path is a Direct Invocation, where the O S Driver directly calls the A C P I slash Bridge Driver, again providing a G U I D and a parameter buffer pointer. This bypasses the A C P I interpreter layer and allows for more direct control, potentially improving performance for frequently used operations.In both cases, the A C P I slash Bridge Driver acts as an intermediary. Upon receiving an invocation, it consults the P R M T to gather the necessary configuration data and constructs the Context Buffer. It then invokes the appropriate P R M handler by calling a function pointer, passing three arguments: the parameter buffer from the O S Driver, the newly constructed Context Buffer, and the handler's own function pointer. This invocation is represented as asterisk P R M underscore H A N D L E R, open parenthesis, asterisk ParamBuffer, comma, asterisk ContextBuffer, close parenthesis, indicating a function call through a pointer with two structured arguments.The P R M Handlers themselves are depicted as a stack of three green blocks, symbolizing modular, layered firmware components that can be independently loaded and executed. This architectural separation enables fine-grained updates and enhances system maintainability.Moving to the software organization of P R M components, the system is structured in three hierarchical levels of increasing specificity. At the top is the P R M interface, which represents the complete set of firmware functionalities exposed to the O S at runtime. This interface abstracts the underlying complexity and provides a unified A P I for platform management.Beneath the interface are P R M modules, which are independently updatable packages containing one or more P R M handlers. Each module is a self-contained unit that can be authored and distributed separately by Original Equipment Manufacturers, or O E M, and Independent Hardware Vendors, or I H V. This modularity supports targeted updates and allows different vendors to contribute to the platform's runtime management capabilities without interfering with each other.At the lowest level are P R M handlers, each implementing a single, atomic function identified by a unique G U I D. These handlers are the executable units that perform specific tasks such as error logging, power state transitions, or hardware diagnostics.The format of a P R M module is based on the P E slash C O F F, or Portable Executable slash Common Object File Format, standard. This format is widely used in executable files and dynamic libraries, providing a well-defined structure for code, data, and metadata. A P R M compliant P E slash C O F F image must include specific characteristics to be recognized as a valid module.One key feature is the Optional Header, which includes the MajorImageVersion and MinorImageVersion fields. These allow the O S loader to inspect the module's version using filesystem A P I s without loading it into memory, enabling version comparison and update decisions based on file metadata alone.Another critical component is the dot edata section, which contains export information used for dynamic linking. Within this section, the P R M Module Export Descriptor is a mandatory structure that describes the module and lists its contained handlers. This descriptor must be present for the image to be considered a valid P R M module. It must also have a valid signature and be named exactly PrmModuleExportDescriptor.The P R M Module Export Descriptor structure begins with the Signature field at byte offset zero, eight bytes long, containing the ASCII string P R M underscore M E D T. This acts as a magic number to confirm the structure's identity. At offset eight, the Revision field, two bytes in size, specifies the version of the descriptor structure itself.At offset ten, the HandlerCount field, also two bytes, indicates how many P R M Handler Export Descriptors are included in the subsequent array. This count determines the length of the variable-sized HandlerExportDescriptorStructure array that follows.At offset twelve, the PlatformGuid field, sixteen bytes in length, contains a G U I D that identifies the specific hardware platform for which this module is intended. This ensures that a module is only loaded on compatible systems, preventing misconfiguration or execution on unintended platforms.At offset twenty eight, the Identifier field, another sixteen byte G U I D, uniquely identifies the P R M module itself, distinct from the platform it targets. This allows multiple modules to exist for the same platform while maintaining individual identity and version control.Finally, starting at offset forty four, the HandlerExportDescriptorStructure array contains one entry for each handler in the module. Each entry maps a handler's G U I D to its ordinal number, enabling efficient lookup by index rather than by string comparison. This improves performance during handler invocation.The dot text section of the P E slash C O F F image contains the actual executable code for the P R M handlers. The Relative Virtual Addresses, or R V A s, of each handler's entry point are computed at compile time and stored in the export table, allowing the loader to locate and call them after the image is loaded.A critical requirement for P R M modules is the presence of a valid relocation table. This allows the P R M loader to load the module at a dynamic base address, avoiding conflicts with other loaded images. Without relocations, the module would be position-dependent and could only be loaded at a fixed address, which is impractical in modern virtual memory systems.In summary, the P R M architecture is designed for modularity, extensibility, and runtime flexibility. The Context Buffer provides essential configuration data to handlers, the Bridge Driver orchestrates invocation and context construction, and the P E slash C O F F based module format enables secure, versioned, and dynamically loadable firmware components. The use of G U I D s for identification, combined with structured metadata and robust error handling, ensures reliable operation across diverse platforms and update scenarios.
