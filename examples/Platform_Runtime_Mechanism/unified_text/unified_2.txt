Two point three. Category three usages.Hardware System Management Interrupts, or H W S M I s, can be generated in response to asynchronous platform events such as memory errors and I O errors. These events occur independently of the processor’s normal execution flow and require immediate attention at the firmware level. When triggered, the System Management Interrupt, or S M I, causes the processor to enter System Management Mode, or S M M, a highly privileged and isolated execution environment. Within this mode, S M I handlers take control to diagnose and respond to the error condition.The primary function of these handlers is to gather detailed diagnostic information about the error. Once collected, this data is either surfaced to the operating system for further processing or logged to a Baseboard Management Controller, or B M C, enabling out of band monitoring and long term system health analysis. In addition to reporting, S M I handlers can initiate Reliability, Availability, and Serviceability, or R A S, events. These actions may include error remediation—such as correcting transient memory faults using Error Correcting Code, or E C C—or mitigation strategies like isolating faulty hardware components to prevent system instability or data corruption.Although the Platform Runtime Mechanism, or P R M, was primarily designed with Category one S M I handlers in mind—those managing time critical and security sensitive platform functions—Category three S M I handlers are also candidates for migration to the P R M framework. This transition is optional and determined by the platform vendor or Original Equipment Manufacturer, or O E M, based on system design goals and operational requirements.Category three S M I handlers are most commonly used for correctable error harvesting and reporting. Correctable errors, while not immediately catastrophic, provide valuable insight into system reliability trends and potential hardware degradation. Instead of invoking a full S M I for these events, a more efficient approach involves generating a System Control Interrupt, or S C I. An S C I operates within the normal operating system context and does not require entry into S M M. When an S C I is issued, it triggers the execution of A C P I Source Language, or A S L, code by the operating system’s A C P I driver. This A S L code can then leverage the P R M infrastructure to perform error data collection and reporting in a less intrusive and more standardized manner. This shift reduces the overhead associated with S M M entry and exit, improves system responsiveness, and enables greater integration with operating system level management tools.Section three. Platform Runtime Mechanism Overview.The Platform Runtime Mechanism, or P R M, represents a significant evolution in system firmware architecture by enabling the migration of certain platform management functions from System Management Mode, or S M M, to the operating system or Virtual Machine Monitor, or V M M, execution context. This transition applies specifically to operations that do not require the extreme privilege level of S M M, including certain Category one usages and a subset of Category three hardware S M I handlers.By moving these functions out of S M M, P R M eliminates many of the drawbacks associated with executing code in that environment. S M M is non preemptable, operates outside the purview of the operating system, and introduces potential latency and security risks due to its opaque nature. In contrast, P R M allows runtime platform firmware handlers to execute within the O S context, where they benefit from better debuggability, lower complexity, and the ability to be updated dynamically without requiring a system reset.The P R M infrastructure is built upon the A C P I Interpreter, providing a standardized mechanism for invoking runtime platform firmware handlers. These handlers, known as P R M Handlers, are placed in a reserved firmware runtime area—such as the U E F I Runtime Services region—by the B I O S during system boot. Importantly, these handlers are updatable during O S runtime, allowing for targeted online servicing of specific platform functionalities without full firmware updates.The A C P I Interpreter based P R M infrastructure is formally referred to as the P R M Op Region Handler within the A C P I C A or A C P I subsystem. In some implementations, it may be logically realized as an independent driver, commonly called a Bridge Driver. The specification uses the terms Bridge Driver, P R M Op Region Handler, A C P I Driver, A C P I Interpreter, and A C P I C A interchangeably, as they all refer to the same underlying mechanism responsible for mediating between the O S and P R M Handlers.P R M Handlers can be invoked through two distinct pathways. The first is direct invocation from an O S driver, which requires both the driver and the O S A C P I subsystem to be P R M aware. This enables efficient, low latency communication between the operating system and platform firmware, supporting modern, integrated system management designs.The second invocation method occurs from the A S L context. This is used when the O S driver is not P R M aware or relies on legacy mechanisms such as the underscore D S M, or Device Specific Method. In this case, platform events that trigger a System Control Interrupt, or S C I, cause the O S A C P I driver to execute A S L code, which then interfaces with the P R M infrastructure. This approach maintains backward compatibility while still enabling the benefits of P R M execution.Figure three one illustrates the P R M overview, depicting two main invocation paths. On the left, an O S driver invokes A S L methods such as underscore D S M through the A C P I interface. A red X clearly marks that S M I is not used in this path, indicating a deliberate move away from S M I based handling for these operations. This branch represents legacy usage models transitioning to P R M execution via the P R M Op Region interface, which connects to the A C P I slash Bridge Driver.On the right, a P R M aware O S driver performs a direct invocation of the A C P I slash Bridge Driver, representing new usage models designed specifically for the P R M framework. The A C P I slash Bridge Driver encapsulates the P R M T, or P R M Table, a critical data structure that defines the metadata and permissions for P R M Handlers. From this driver, control flows to the P R M Infrastructure and then to the P R M Handlers, shown as a stack of three green blocks, emphasizing their modular and updatable nature. The diagram explicitly labels this block as P R M Handlers in lieu of S M I Handlers, underscoring the architectural intent to replace traditional S M I handlers with a more secure and manageable alternative.Section three point one outlines the core requirements for P R M Handlers. First, they must be capable of executing within the context of a running operating system. This means they operate under O S scheduling and memory management, rather than in an isolated, high privilege mode like S M M.Second, P R M Handlers loaded at boot time must be part of the firmware boot chain of trust. This ensures their authenticity and integrity are verified during the secure boot process, preventing unauthorized or malicious code from being loaded.Third, any internal pointers within a P R M Handler must be fixed up during boot based on the O S virtual address space. This allows the handler to be properly relocated and integrated into the O S’s virtual memory layout, supporting dynamic memory allocation and avoiding address conflicts.Fourth, P R M Handlers must be O S agnostic and must not depend on any operating system provided support A P I’s. This requirement ensures portability across different operating systems and prevents tight coupling that could hinder deployment or updates.Fifth, a P R M Handler must be securely replaceable or over rideable during runtime without requiring a system reset. This enables live updates for bug fixes, security patches, or feature enhancements, which is essential for high availability systems.Sixth, P R M Handlers must be executable by the O S, interruptible, and single threaded. Being interruptible ensures they do not block other system operations, allowing the O S scheduler to maintain responsiveness. The single threaded requirement simplifies design and avoids concurrency issues such as race conditions.Seventh, P R M Handlers shall only access Memory Mapped I O, or M M I O, registers that are explicitly listed in the handler’s parent module’s `RuntimeM M I O Pages` field within the P R M T. This creates a strict access control policy, limiting hardware interaction to only those registers necessary for the handler’s function and preventing unauthorized access to sensitive system resources.Eighth, P R M Handlers must not contain any privileged instructions. This restriction is fundamental to the security model of P R M. By prohibiting instructions that manipulate processor privilege levels, control registers, or other protected state, the handlers are confined to user level or ring zero O S context without the ability to escalate privileges or bypass O S protections. This significantly reduces the attack surface and ensures that even if a handler is compromised, its potential for harm is strictly bounded by the permissions granted through the P R M T and enforced by the O S and hardware.
