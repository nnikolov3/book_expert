Six point one point one point two, P R M Handler Export Descriptor Structure.The structure of the P R M Handler Export Descriptor is defined by two primary fields: Handler G U I D and Handler Name. This descriptor serves as a bridge between a unique binary identifier and a human readable label for a specific Platform Runtime Mechanism handler.The first field, Handler G U I D, occupies sixteen bytes beginning at byte offset zero. This G U I D is a one hundred twenty eight bit globally unique identifier that provides an unambiguous reference to a specific P R M handler. It maps directly to the corresponding handler name within the same descriptor, ensuring that each handler can be uniquely identified across different systems and software components. The use of a fixed sixteen byte length guarantees consistent parsing and alignment in memory, which is essential for reliable firmware and operating system interactions.Following the G U I D, at byte offset sixteen, is the Handler Name field, which spans one hundred twenty eight bytes. This field contains a null terminated or padded string that represents the human readable name of the P R M handler. The name is intended for diagnostic, logging, or administrative purposes, allowing developers and system tools to identify the handler without requiring interpretation of the raw G U I D. The fixed size ensures predictable memory layout and simplifies allocation, though it may result in unused padding if the actual name is shorter than the maximum allowed length. Together, the pairing of a cryptographically unique G U I D with a descriptive name enables both machine level precision and user level clarity in system management.Six point two, P R M Module Loader.The P R M module loader is a software component responsible for managing the lifecycle of P R M modules within the system. Its responsibilities include four key actions: first, authenticating P R M module binary images; second, validating that the image complies with the architectural and functional requirements specified in the document; third, loading the P R M module into a valid memory address range that is executable by the host operating system; and fourth, updating relevant system data structures to make the P R M module available for use by other system components.Authentication involves verifying the integrity and origin of the binary, typically through cryptographic means such as digital signature validation using trusted root keys and hash verification to detect tampering. This step is critical for maintaining the security and trustworthiness of the system, especially when loading code that operates in a privileged runtime environment.Validation ensures that the binary conforms to expected structural and behavioral standards. This may include checking version compatibility, verifying metadata, confirming adherence to the required binary format, and ensuring compliance with the Application Binary Interface expected by the system. This process prevents malformed or incompatible modules from being loaded, thereby avoiding potential system instability or undefined behavior.Loading the module requires allocating executable memory, copying the binary content into that region, and configuring the memory management unit to mark the region as executable while preserving memory protection boundaries. The allocated memory must reside within an address range accessible and permissible for execution by the host operating system.Finally, the loader updates system data structures such as dispatch tables, service registries, or control blocks to register the newly loaded module. These updates allow other components to discover and invoke the services provided by the P R M module, effectively integrating it into the system’s operational framework.Six point two point one, Firmware P R M Loader.The baseline P R M module is distributed as part of the platform firmware image, and its loading is managed by a firmware based P R M loader. This loader operates during the early stages of system boot, typically as a component within the B I O S or U E F I firmware environment, such as a U E F I D X E driver. It executes before the operating system is initialized, making it suitable for establishing foundational runtime services.The P R M module image is usually stored on the same non volatile storage device that holds the system boot firmware, such as a flash memory chip on the motherboard. However, the specification allows for loading from alternative storage media, including external drives or network sources, providing flexibility in deployment and update scenarios.A distinctive responsibility of the firmware P R M loader is the creation and publication of the P R M T A C P I table. This table is dynamically generated based on the P R M modules discovered and successfully loaded during the boot process. The P R M T table is then made available to the operating system through the A C P I interface, enabling the O S to enumerate and interact with the available P R M handlers. This mechanism ensures standardized, cross platform compatibility and allows the operating system to manage platform specific runtime functionalities in a consistent manner.Six point two point two, O S P R M Loader.The O S P R M loader enables updates to P R M modules during operating system runtime, allowing modifications to platform runtime functionality without requiring a system reboot. This capability supports continuous operation and high availability, particularly in enterprise or mission critical environments where downtime must be minimized.When a P R M update is initiated at runtime, an operating system level software component assumes the role of the P R M loader. This component must enforce two primary requirements. First, P R M updates must be applied in a monotonically increasing version sequence. That is, an update with a version number less than or equal to the currently installed version must be rejected. This rule prevents accidental or malicious downgrades, ensuring that the system state progresses forward in a controlled and secure manner.Second, the update process must be designed to minimize disruption to P R M functionalities that are in use by other operating system components. This implies the use of atomic update techniques, hot swapping mechanisms, or shadowing strategies that allow the transition between old and new module versions to occur with minimal or zero downtime.An important limitation of the O S P R M loader is that it can only replace existing P R M modules that were originally published during the firmware boot phase and registered in the P R M T A C P I table. It cannot introduce new P R M handlers that were not previously declared by the firmware. This restriction ensures that the firmware retains authoritative control over the initial set of available platform services, preserving system integrity and preventing unauthorized expansion of the runtime interface surface.Six point three, P R M Handler.A P R M handler is a function contained within a P R M module. It represents a callable entry point that provides a specific runtime service or functionality to the system.Six point three point one, Overview.Each P R M handler must be assigned a unique G U I D by the module author. This G U I D, along with the corresponding function name, must be recorded as a pair in the P R M Module Export Descriptor. This descriptor acts as a manifest that enables the P R M module loader to resolve the G U I D to the physical memory address of the handler function at load time.The resolution process allows the system to dynamically bind callers to the correct handler implementation, supporting modularity and late binding. This mechanism is essential for enabling updates, replacements, and dynamic discovery of services without requiring recompilation of dependent components.Six point three point two, Function Signature.All P R M handlers must adhere to the architecture specific calling convention defined for U E F I Runtime Services in the U E F I specification. This ensures binary compatibility and predictable behavior across different implementations and compilers.The standard function signature for a P R M handler returns an E F I underscore S T A T U S type, indicating the success or failure of the operation through a detailed status code. The function is declared with the P R M underscore E X P O R T underscore A P I keyword, which instructs the compiler to include the function in the module’s export table, making it accessible to external components.The function takes two parameters, both optional and passed by reference as virtual address pointers. The first parameter is Parameter Buffer, a pointer to a V O I D type buffer allocated by the caller. This buffer carries input or output data whose internal structure is defined by a private contract between the caller and the handler. If no data is to be passed, the caller provides a N U L L pointer, and the handler must check for this condition before accessing the buffer.The second parameter is Context Buffer, a pointer to a P R M underscore M O D U L E underscore C O N T E X T underscore B U F F E R. This buffer contains context specific information such as module state, configuration data, or virtual address references to other resources. All addresses contained within the Context Buffer must be virtual addresses, consistent with the virtual memory model used by the operating system and runtime environment. The Context Buffer may be N U L L if no context is available, and the handler must perform a null check before dereferencing it.The E F I underscore S T A T U S return type and the E F I A P I calling convention are adopted directly from the U E F I specification, ensuring consistency with existing runtime service interfaces. The P R M underscore E X P O R T underscore A P I macro ensures that the function is properly exported in the object file, enabling symbol resolution during module loading.Additional requirements for P R M handlers include the use of the P R M underscore E X P O R T underscore A P I macro to place the function into the image’s export table. This is mandatory for any function to be recognized as a publicly accessible P R M handler.The maximum name length for a P R M handler function is one hundred twenty eight bytes. This limit ensures predictable memory usage in symbol tables and prevents potential buffer overflow issues during name resolution or logging operations.Every P R M handler must have a corresponding entry in the P R M Export Descriptor Table. Without such an entry, the handler will not be recognized as a valid service endpoint by the P R M module loader, and thus will not be available for invocation.Functions within the P R M module that are not intended for external use are considered private to the module. These internal functions must not be exported and should not appear in the module’s export table. This encapsulation principle ensures that only designated A P I entry points are exposed, reducing the attack surface, preventing unintended dependencies, and supporting clean module boundaries. By enforcing strict separation between public handlers and private implementation details, the architecture promotes maintainability, security, and long term evolvability of the P R M system.
