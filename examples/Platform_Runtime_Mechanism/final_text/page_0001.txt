1. Introduction.

1.1 Background on System Management Mode (SMM).

System Management Mode, or S M M, is an operating mode in the X eighty six computer architecture. S M M code is written within the context of the system firmware and typically used for system wide functions which are highly platform and silicon specific. Some examples would be R A S, such as hardware errors like memory E C C, or to take corrective hardware actions to extend system uptime, power management, execution of O E M proprietary code, platform hardware events, and implementation of hardware workarounds.

In order to enter S M M, a System Management Interrupt, or S M I, must be generated by a platform event. S M I is a high priority, non maskable, broadcast interrupt. On receipt of this interrupt, the processors in the system save their context in S M Ram and transition to S M M to execute the corresponding S M I Handler for the given event.

The S M I handler code then sets up its own environment, including page tables, I D T s, and identifies the source of S M I and handles that event accordingly. The S M I handler is placed by the platform B I O S during boot to a special area of memory called System Management Ram, or S M Ram.

S M Ram is invisible to O S or V M M. A processor executing in the zero to three ring privilege levels will not be able to read from or write to S M Ram space. When the processor switches to S M M on receipt of an S M I, then the processor executes code out of the S M Ram area.

There are two different categories of S M I sources, asynchronous and synchronous. S M I s due to platform and hardware events are asynchronous in nature. Software S M I s are invoked by writing to Port hexadecimal zero x B two, in I N T E L Architecture platforms, and are synchronous in nature.

The document describes the Platform Runtime Mechanism, or P R M, as a means to remove usage of certain classes of S M I handlers. P R M, along with Native O S drivers and offload to other hardware engines such as a Baseboard Management Controller, or B M C, offer a path to eliminate runtime S M I s.

1.2 Issues with SMM â€“ Problem Statement.

As described in the previous section, S M M mode of operation has the following key attributes. First, S M Ram, which is a memory space where S M I Handlers reside, is a Black Box to the O S or V M M. Second, S M I Handlers run with their own page tables and accessibility to all system resources, being higher privileged than ring zero. Third, S M I is non maskable, broadcast, and opaque to the O S or V M M. Fourth, once in S M M Mode, all other interrupts are pended.

1.2.1 SMI and Perf/QoS degradation.

S M I is a global broadcast event which stalls all system processors. On receipt of an S M I, all the C P U threads in the system enter S M M mode immediately after completing their current instruction. This leads to unpredictable performance jitters.

Once inside the S M M environment, threads are not available for O S use, and their execution is stalled until the S M I handler relinquishes control back to the previously executing context. The amount of execution time in S M M is called S M M Latency. In a typical four socket server class.