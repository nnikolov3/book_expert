The shell's default behavior is to incorporate the root of each drive, recognizing directories such as efi tools and efi boot. This implies that any utility seeking to present itself as an internal command must reside within one of these three designated directory structures. For seamless integration of an automatic help system, a dedicated help file is stipulated. This file must share the same name as its corresponding application, and its content, typically stored in a dot man file format, should mirror the structure of the shell's internal commands, with the exception of information accessed via the Human Interface Infrastructure, or H I I.When an internal command, whether defined in a profile or as an external application, is invoked, it inherits the same privileges and access levels as the shell itself. A curated set of actions, primarily focused on core shell functionalities, can be accessed via the U E F I Shell Command Library. These actions are categorized, including shell script interaction, shell alias interaction, and shell map interaction. It is noteworthy that the direct linking of a shell application with this library will function correctly, provided that the library is also linked to the shell's core. This linkage specifically pertains to internal shell commands, ensuring their functionality is exclusively available to the core shell environment.The help system, as implemented within the U E F I Shell version 2 point 0, operates by automatically parsing a help file. This occurs when a user invokes the help command, for instance, by typing help less than Your App Name greater than. The help file must be located in the same directory as the application it supports. Furthermore, the Unicode text file format utilized for these help files must adhere to a specific structure, implied to be consistent across all such files. A typical help file structure would include sections such as name, synopsis, description, examples, and return values, each providing detailed information about the command's purpose, usage, and expected behavior.Once a help file is properly configured, there is little distinction to a normal user of the shell between a custom command and an internal command. However, there are two notable differences: internal commands take precedence over applications with the same name, and internal commands are listed via the help command, whereas external applications are not. To override the default behavior of internal command precedence, a user can specify the file name with the efi extension. Similarly, to override script files, the nsh extension can be used.Shells are frequently distributed by one of two common methods: binary distribution and code distribution. The benefits of binary distribution are simplicity and convenience without any overhead, as it eliminates the need for compilation by the end-user. In contrast, code distribution involves providing the source code, which requires users to compile it themselves, offering customization but with a higher overhead to integrate into a firmware image. The binary E F I Shell is distributed in binary form via S V N in the E D K and E D K 2 standard distributions, available at http colon slash slash www dot tianocore dot org. This binary comes in two sizes, with the larger image having more commands available. The binary U E F I Shell is also distributed in binary form via S V N in the E D K 2 and via U D K releases, located at the same website.The source for the E F I Shell is located in an E F I Shell subproject called efi shell, accessible at http colon slash slash efi shell dot tianocore dot org, with two build files supporting different versions. The source for the U E F I Shell is located via S V N in the E D K 2 and in the U D K distributions at http colon slash slash edk 2 dot tianocore dot org. Customization of the U E F I Shell is controlled by Platform Configuration Database entries and configured in the D S C file used for building the shell.Regarding graphical user interfaces, or G U I s, there is no inherent support within the shells discussed. However, methods in the Human Interface Infrastructure, or H I I, can be utilized for configuring and performing localized displays. This can be achieved via the HiiLib in U D K slash E D K 2 or directly through H I I protocols, as detailed in Chapters 2 9 and 3 0 of the U E F I specification. Another possibility is to use libraries to achieve G U I functionality, such as the C Library in U D K slash E D K 2, which could potentially be used to compile standard graphics libraries for use in the shell. Some companies have developed libraries for application development, with some solutions available for purchase and others used internally. An example of a publicly available solution is the A M I distribution.
