The operation of UEFI runtime services is a critical aspect of modern operating systems, particularly in the context of Windows and Linux. A fundamental requirement for these systems is that the second-stage boot loader must call ExitBootServices() before handing control over to the operating system kernel. However, to support calling UEFI services from a virtual memory-enabled kernel, it is necessary for the kernel and UEFI callback mechanism to agree on a new address structure. UEFI systems operate in protected unpaged mode, whereas Windows and Linux systems are fully fledged paged OS environments. The UEFI runtime subsystem operates in protected unpaged mode, whereas the kernel has switched execution over to paged mode. When a kernel makes a runtime call to UEFI, two key issues emerge. Firstly, each callback to UEFI could potentially switch the processor back to UEFI's default protected unpaged mode. This mode switching is undesirable due to its slow speed, complexity in managing paging, and security concerns arising from unfettered memory access.Alternatively, the UEFI callback must operate within the paged mode of the operating system. This implies that the callback mechanism needs to handle data references and pointers, which are typically virtual addresses, and correctly translate them to physical addresses. For instance, data at hexadecimal F F one two three four five six seven eight physical may be mapped by Linux to hexadecimal D two three four five six seven eight, and the UEFI system should reference the new address. To achieve this agreement between a paging kernel and the UEFI Runtime Services, the UEFI standard defines the function SetVirtualAddressMap. After mapping UEFI runtime data or code to a set of virtual addresses, the OS kernel will make this callback to EFI before making any further UEFI Runtime Service calls. This function is crucial for ensuring that the UEFI system and the operating system maintain a consistent view of memory, which is essential for features like memory protection and efficient memory utilization.In addition to the standard UEFI-based solutions, there are alternative boot strategies. One such option, referred to as "Neither Option," is reserved for Real-Time Operating Systems (RTOS) or modified Linux kernels. This approach requires the OS loader to not rely on any BIOS boot services or legacy BIOS calls, operating within a "closed box" with a singular, permanent boot path. This design principle is ideal for systems integrated into the firmware, such as flash-based or SPI-based systems, which may also be microkernels or free RTOS.Within a UEFI-based boot scenario, a developer may choose to load the operating system as a DXE payload, where the operating system is loaded and jumped to as part of the initial BIOS driver load. Alternatively, a legacy-based solution involves performing a direct memory access (DMA) of the OS kernel into a known memory location and then jumping to start the kernel. Furthermore, an alternative OS loading model can be implemented where the UEFI-based firmware is bifurcated, and the loader and DXE are placed on removable media, allowing for flexible booting mechanisms.The blind handoff to disk, a process where the system firmware initiates a transfer of control to a known disk address without explicit verification, is a preference among RTOS vendors who do not call back into system firmware during runtime and have not yet implemented either a legacy OS interface or an EFI interface. While this approach might be expedient for development or initial deployment, it bypasses more robust initialization and validation sequences, potentially leading to security or stability concerns if the target address is compromised or incorrect.In conclusion, loading an operating system after platform initialization can be achieved through various methods. Known and tested standards, such as UEFI, provide the fastest and easiest solutions for flexible booting. However, more deeply embedded solutions require careful consideration beyond the lab environment, especially when targeting high-volume manufacturing. The choice of boot solution should be dictated by the specific circumstances of the system, and with UEFI, it is possible to implement a variety of boot paths without being limited to a single solution.
