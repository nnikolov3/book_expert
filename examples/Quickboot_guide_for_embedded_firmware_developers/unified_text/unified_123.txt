The system boot process is a complex sequence of events that involves the execution of various firmware components, including DXE modules, within specific time constraints. To ensure proper sequential execution and prevent interference, these modules are allocated specific time budgets. For instance, the CPU DXE and PCH DXE modules each have an extended time budget of one hundred milliseconds, while the ME DXE budget is set at ten milliseconds, excluding MEBx during the Bn state. Option ROMs, which are legacy firmware extensions, are permitted zero milliseconds of execution time, indicating they are either disabled or not expected to contribute to the boot time in this configuration. Similarly, the Raid Storage Technology ROM is also allocated zero milliseconds when operating in AHCI mode, implying that in this specific storage controller configuration, the RAID functionality provided by the ROM is bypassed or handled by a more integrated driver.The BDS phase budget is specified as five hundred milliseconds, designated as the time for only one boot target to complete its initialization. The GOP module is constrained to a one hundred millisecond budget for displaying dynamic text, which is a critical element of user feedback during the boot sequence. The TSL, or transient layer, is allocated a five hundred millisecond budget. The OS bootloader time is considered to be after the BIOS boot has concluded, and its execution time contributes to the overall end-to-end boot duration, implying that optimization of the bootloader is important for overall system performance.In addition to these time budgets, the system also has fallback mechanisms in place to handle exceptions that may occur during the boot process. These exceptions can stem from hardware changes, such as those involving the CPU, memory, display, input devices, boot target, or the real-time clock battery. BIOS setting modifications are also identified as a trigger for events, potentially affecting the boot target and console input/output operations. Furthermore, software changes, specifically UEFI updates, are cited as another source of exceptions.The system categorizes exceptions into four types, each with distinct characteristics and implications for the boot flow. A Type 1 exception can be completely handled within an EFI module and does not require a reset, allowing the boot process to continue with minimal disruption. A Type 2 exception occurs when a BIOS module encounters an issue that prevents the rest of the BIOS from continuing the fast boot framework, resulting in the remainder of the boot sequence executing as a full boot. Type 3 and Type 4 exceptions require a system reset and result in a full boot, with the latter involving full memory retraining.The classification of exceptions into these types is crucial for determining the appropriate response to ensure system stability and bootability. Table 11.2 provides a summary of the exception types, their current boot flow behavior, and the subsequent boot flow. Table 11.3 lists specific examples of exceptions and their probable type casting, which can vary depending on the policy decisions of the designer. Understanding these exceptions and their implications is essential for designing and implementing robust boot mechanisms that can handle a wide range of scenarios and ensure reliable system operation.The discussion of these exceptions and their handling mechanisms highlights the complexity and nuance of the system boot process. The interplay between hardware, firmware, and software components requires careful consideration to ensure that the system can recover from exceptions and maintain its integrity. By allocating specific time budgets to different components and implementing fallback mechanisms, the system can mitigate the impact of exceptions and provide a robust and reliable boot experience. The classification and handling of exceptions are critical aspects of this process, and their proper implementation is essential for ensuring the overall stability and performance of the system.
