The process of booting a Linux kernel within a modern Unified Extensible Firmware Interface, or U E F I, system, involves a transition from a standard bootloader to a more direct execution model. Initially, a system's standard bootloader, such as G R U B, might be used, with paths like E F I boot gr ub dot E F I for a Linux system or C colon backslash Windows backslash System32 backslash winload dot E F I for a Windows system. A second-stage bootloader, as shown in Figure eight point one, will then hand off control from the second stage to the runtime system by first locating the bootloader configuration file, if any, and then executing commands contained in that configuration file in the following order: One, locate a kernel image. Two, locate any ancillary boot data, such as an init R A M disk. Three, Optional: convert an E F I memory map to E eight hundred twenty h tables, for systems that do not support U E F I Runtime Services. Four, call Exit Boot Services parentheses. Five, execute the kernel with parameters given in the boot loader configuration file.The interaction involves a second stage bootloader, which takes control from the initial bootloader. This second stage then hands off to the runtime system, first by locating the bootloader configuration file. It then proceeds through a sequence of operations: locating a kernel image, finding ancillary boot data like an init R A M disk, and optionally converting an E F I memory map to E eight two oh h or E eight oh one h tables, particularly for systems that do not support U E F I Runtime Services. Finally, it calls Exit Boot Services parentheses and executes the kernel with parameters specified in the bootloader configuration.Modern U E F I systems, in conjunction with modern versions of the Linux kernel, can directly execute a Linux kernel without the need for an intermediate second stage bootloader. This is facilitated by the Linux kernel's ability to obtain the E F I memory map through a direct call to U E F I Runtime Services. This capability eliminates the necessity of a second stage bootloader to translate the E F I memory map. This advancement is backward compatible, enabling the addition of an E F I S T U B kernel configuration option, which allows the system to seamlessly use this configuration or directly execute the kernel as previously described.The diagram illustrates a typical workflow for a second-stage boot loader, a critical component responsible for initializing the system and loading the operating system. The process begins with the Firmware entering the Boot Device Selection, or B D S, phase. This phase is crucial for identifying and preparing the storage device from which the subsequent boot loader stages will be loaded. Following the B D S phase, the system attempts to read the second-stage boot loader from a known offset on a legacy S P I flash memory. This is a common practice for storing essential boot code, as S P I flash offers non-volatile storage directly accessible by the system's firmware. The integrity of this read boot loader is then verified. If the R o T image valid check fails, the system indicates a boot failure.Assuming the initial boot loader is valid, the process proceeds to the G R U B stage, which is responsible for reading the boot loader configuration from the target file system. G R U B, or G R and Unified Bootloader, is a widely used boot loader for Unix-like systems, capable of managing multiple operating systems and complex boot configurations. Again, a validation step for the R o T image follows. If this validation fails, it results in a boot failure. Upon successful validation of the G R U B-related boot loader configuration, the next step involves the boot loader reading the operating system kernel and the initial ramdisk, or initrd, from file systems such as F A T thirty two, E X T three, or E X T four. These file systems are typically located on storage devices like S D I O or e M M C, which are common integrated storage solutions in embedded systems and mobile devices. The validity of these R o T images is assessed.Finally, if all prior validation checks are successful, the system hands off control to the run-time environment, as specified in the boot loader configuration. This signifies the successful completion of the boot sequence, with the kernel and initrd loaded and ready to take over system control, initiating the full operating system load. Each boot fail state represents a critical failure in the boot process, necessitating diagnostic intervention.Operating system kernels, such as those used in Windows and Linux systems, assume and require the second-stage boot loader to have called Exit Boot Services parentheses before handing control over. In order to support calling U E F I services from a virtual-memory-enabled kernel, however, it is necessary for the kernel and U E F I callback mechanism to agree on a new address structure. Recall U E F I systems operate in protected unpaged mode, whereas Windows and Linux systems are fully fledged paged O S environments. The U E F I runtime subsystem operates in protected unpaged mode, whereas the kernel has switched execution over to paged mode; therefore, when a kernel makes a runtime call to U E F I, one of two things must logically happen. One, each callback to U E F I could switch the processor back to U E F I's default mode of protected unpaged mode. This is undesirable, however, for a number of reasons: slow to switch modes back and forth, complex to enable or disable paging between the two modes, and considered unsafe security-wise as the U E F I callback has unfettered access to memory. Two, the U E F I callback must now itself operate in paged mode, replacing function and data references or pointers to physical addresses with virtual addresses, thus ensuring compatibility and security between the U E F I runtime services and the operating system kernel. This approach enables efficient and secure interaction between the U E F I firmware and the operating system, facilitating the use of U E F I services in virtual-memory-enabled kernels.
