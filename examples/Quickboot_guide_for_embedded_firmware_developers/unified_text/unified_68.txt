The Unified Extensible Firmware Interface, or U E F I, environment supports system loader applications, which are distinct from shell applications. A shell application is one that must run after the shell application, itself a U E F I application, has started. This execution model offers several advantages, including parameter handling, file system interaction, and access to the broader environment.When a U E F I application starts, it receives its parameters as a single long array of sixteen-bit characters, known as C H A R sixteen. The application is responsible for parsing these arguments, which may include handling quoted strings to delineate complex parameters. In contrast, a U E F I shell application receives its arguments in a more structured form, similar to the 'Argc' and 'Argv' parameters in standard C applications. This simplifies application development, allowing for smaller and more maintainable code.The file system within the U E F I environment is accessed through Device Paths, which are not inherently user-friendly for direct human interpretation. For example, the Device Path for a Universal Serial Bus, or U S B, hard disk drive might be represented as PciRoot open parenthesis hexadecimal zero, zero close parenthesis slash Pci open parenthesis hexadecimal one D, hexadecimal zero three close parenthesis slash U S B open parenthesis hexadecimal one, hexadecimal zero close parenthesis. The U E F I shell often translates these intricate Device Paths into more comprehensible, human-readable map names, such as F S zero, making it easier for users to refer to storage devices.The shell environment provides additional features, including path searching for specified files, aliases for substituting one command with another, and environment variables that can be dynamically replaced with predetermined or configurable values. The shell also incorporates utility functions for file system operations, such as identifying files that match wildcard patterns, enumerating devices, and retrieving supplementary information about files. However, the method used to access these features differs between the E F I Shell and the U E F I Shell version two point zero, requiring additional development effort to ensure compatibility and support for both types of U E F I shells.When developing applications for the U E F I environment, several trade-offs must be considered. One key decision is whether the feature set provided by the shell justifies the requirement that the application run under it. Alternatively, developing a U E F I application directly might offer a more streamlined solution. Another significant trade-off concerns the binary size implications of adopting the U D K two thousand and ten library to support both the E F I and U E F I shells. While this library offers a convenient way to automatically detect the shell version and handle inter-shell differences, it introduces an increase in the overall binary footprint.The code for a simple "Hello World" U E F I application demonstrates the fundamental structure of interacting with the system and performing output. The application receives a handle representing the image of the current application and a pointer to the system table, which acts as a central repository of pointers to various services provided by the U E F I firmware. The code then accesses the console output device through the system table and invokes the OutputString function to print a string. In contrast, a U E F I Shell application would replace the call to OutputString with a call to ShellPrintEx, highlighting the differences in interacting with the system between U E F I applications and U E F I Shell applications.The difference between U E F I applications and U E F I Shell applications becomes more apparent when considering file operations. A U E F I Shell application can open a file named file dot txt using the gShellProtocol pointer and the OpenFileByName function, which takes the file name, a handle, and the file mode as arguments. In contrast, a U E F I application must navigate the file system using Device Paths, which can be complex and require additional logic to handle path searching and file mode specification. This complexity underscores the importance of carefully evaluating the trade-offs involved in developing applications for the U E F I environment and choosing the most appropriate approach based on the specific requirements and constraints of the project.
