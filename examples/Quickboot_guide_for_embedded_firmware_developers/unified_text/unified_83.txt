The initiation sequence of a processor commences with the de-assertion of the reset line. Following this event, newer processors may initiate a microcode update as a part of their secure startup sequence. Any correctable errata discovered are rectified before the execution of any user code, thereby enhancing system security. Upon successful patching, the processor proceeds to fetch its initial instructions. The location from which these initial instructions are fetched is termed the reset vector. This reset vector can either contain the actual starting instruction sequence directly or serve as a pointer to it, typically residing in flash memory. The specific address of this vector is architecture dependent, usually fixed within the processor's design. The initial address must be a physical address, particularly relevant if the M M U, or memory management unit, has not yet been enabled. For Intel architecture, for instance, the initial fetching instructions commence at hexadecimal F F F F, F F F F zero. Only sixteen bytes are allocated at the top of memory, and these bytes are expected to contain a far jump instruction to the remainder of the initialization code. This particular code segment is invariably written in assembly language and, at the time of writing, there is no provision for a software stack or the utilization of cache as Ram.Because the processor cache is not enabled by default at this stage, it is not uncommon to flush the cache in this initial phase using a W B I N V instruction. While this instruction is not necessary on more recent processors, its inclusion does not negatively impact functionality. The text further explains that the processor then begins executing instructions, with the code being written in assembly language due to the absence of a software stack or cache as Ram.The discussion then transitions to "Mode Selection," specifically within the context of I A thirty-two architecture. It states that I A thirty-two processors support three primary operating modes, in addition to one quasi-operating mode. Among these, "Protected mode" is identified as the native operating mode. This mode provides a rich set of architectural features, flexibility, high performance, and backward compatibility to the existing software base. Real address mode or real mode is the operating mode that provides the programming environment of the Intel eight zero eight six processor, with a few extensions, such as the ability to switch to protected or system management mode. Whenever a reset or a power-on happens, the system transitions back to real address mode.System management mode, or S M M, is a standard architectural feature in all I A thirty-two processors, beginning with the Intel three hundred eighty-six S L. This mode provides an operating system or executive with a transparent mechanism for implementing power management and O E M differentiation features. S M M is entered through activation of an external system interrupt pin, S M I hash, which generates a system management interrupt, S M I. In S M M, the processor switches to a separate address space while saving the context of the currently running program or task. S M M-specific code may then be executed transparently. Upon returning from S M M, the processor is placed back into its state prior to the S M I.Normally, the system firmware creates an S M I handler, which may periodically take over the system from the host O S. There are normally workarounds that are executed in the S M I handler and handling and logging off errors that may happen at the system level. As this presents a potential security issue, there is also a lock bit that resists tampering with this mechanism. Real-time O S vendors often recommend disabling this feature because it has a potential of subverting the nature of the O S. However, if the S M I handler can work with the R T O S development, there are some additional advantages to the feature.Another mode supported by the processor is Virtual-eight zero eight six mode, a quasi-operating mode that allows the processor to execute eight zero eight six software in a protected, multitasking environment. Intel sixty-four architecture supports all operating modes of I A thirty-two architecture and I A-32e modes. I A-32e mode, in particular, supports two submodes: compatibility mode and sixty-four-bit mode. Sixty-four-bit mode provides sixty-four-bit linear addressing and support for physical address space larger than sixty-four gigabytes. Lastly, compatibility mode allows most legacy protected-mode applications to run unchanged. The processor's ability to move between these operating modes is crucial for ensuring compatibility, flexibility, and high performance in various computing environments.
