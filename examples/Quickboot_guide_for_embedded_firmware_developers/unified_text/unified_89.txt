The system's firmware plays a crucial role in managing memory configurations, particularly for embedded systems that utilize soldered down Random Access Memory, or Ram, on the board. During the boot process, this firmware is responsible for discovering and populating the necessary configurations, a process often referred to as memory down. This behavior is exemplified in platforms like those from the Intel Computing Group, where the System on Chip, or Soc, interfaces with memory controllers. These controllers, operating at current Ram speeds, must manage the physical transmission lines connecting to the memory modules. To ensure reliable operation over varying environmental conditions such as temperature and drive strength variations, the Soc employs capabilities like resistive compensation, often managed by a delay locked loop, or Dll.When a platform supports add-in-modules for memory, such as dual in-line memory modules, or Dimms, standardized form factor parameters are used. Each Dimm typically includes a serial Electrically Programmable Read-Only Memory, or Eprom, containing Serial Presence Detect, or Spd, data. This Spd data provides essential configuration information for the memory device. The firmware reads this Spd data to subsequently configure the memory subsystem. A serial Eprom is often connected via the System Management Bus, or Sm Bus, enabling the device to be accessible during the early initialization phases of the system. This allows the software to properly establish memory parameters. For memory down motherboards, this mechanism can also be extended to incorporate serial presence detect Electrically Erasable Programmable Read-Only Memories, or Eeproms, facilitating efficient handling of multiple and updatable memory configurations through a unified Basic Input Output System, or Bios, algorithm.Following the initialization of the memory controller, several subsequent cleanup operations are performed. The process of memory testing is integrated into the power on self test, or Post, sequence, often referred to as the Memory Reference Code, or Mrc. While this testing is a standard part of system initialization, it is also possible to extend it with additional tests to thoroughly validate memory functionality, particularly on a cold boot scenario. Developers creating custom firmware must carefully balance the thoroughness of these memory tests with the desired boot time, especially in highly embedded or mobile device contexts where extremely fast boot times are paramount.If memory testing is warranted for a specific design, the optimal time to conduct these tests is during the post initialization phase, when the system is idle and the Operating System, or Os, has not yet assumed control of the platform's subsystems. Memory errors often manifest in unpredictable ways, and hardware features designed to assist in this testing can be invaluable. Historically, such features were predominantly found in high-end servers, but they have increasingly become integrated into client and embedded markets. A critical aspect of modern memory reliability is the implementation of error correction codes, or Ecc. Many embedded devices benefit from Ecc memory, which may necessitate specific initialization procedures. After a power up event, the integrity of the Ecc correction codes themselves must be validated. Writing to memory ensures that the data written, along with the associated Ecc bits, are correctly programmed into their respective locations.For security sensitive applications, it is often a requirement to zero out the entire memory space, either manually or by the Bios. Some memory controllers might even incorporate hardware features to facilitate this zeroing process, thereby reducing the time required. The specific memory initialization procedures, including whether a full memory wipe or Ecc initialization is performed, can be dependent on the system's reset and security requirements, especially in the context of a warm reboot. If there were any memory timing changes or other configuration changes that require a reset to take effect, this is normally the time to execute a warm reset. That warm reset would start the early initialization phase over again; affected registers would need to be restored.From the reset vector, execution starts off directly from the nonvolatile flash storage, or Nv Ram. This operating mode is known as execute in place, or Xip. The read performance of nonvolatile storage is much slower than the read performance of Ram. The performance of the code running from flash is much lower than if it executed from Ram, so most early firmware will copy from the slower nonvolatile storage into Ram. The firmware starts to run the Ram copy of the firmware. This process is sometimes known as shadowing. Shadowing involves having the same contents in Ram and flash; with a change in the address decoders, the Ram copy is logically in front of the flash copy, and the program starts to execute from Ram. On other embedded systems, the chip selects ranges are managed to allow the change from flash to Ram execution. Most computing systems run as little as possible in place. However, some constrained, in terms of Ram, embedded platforms execute all the application in place. This is generally an option on very small embedded devices. Larger systems with main memory generally do not execute in place for anything but the very initial boot steps before memory has been configured. The firmware is often compressed instead of a simple copy, allowing reduction of the Nv Ram requirements for the firmware. However, the processor cannot execute a compressed image in place.
