The process of testing device drivers and applications within a system environment, particularly focusing on the role of the Unified Extensible Firmware Interface, or U E F I, is a complex and multifaceted one. Commands are available to facilitate driver testing and debugging, with specific driver profiles like "Drivers one" and "Debug one" stored within the U E F I Shell, which is part of the E F I Shell. The comprehensiveness of driver testing is contingent on the driver's type. For drivers associated with storage media, a common testing methodology involves verifying correct protocols during the driver's installation. This verification extends to the platform's interaction with the driver stack, including reading and writing data to and from the storage medium. Crucially, it also involves confirming that the driver properly frees allocated memory upon unloading. A robust approach to testing these drivers entails executing an installation program within a U E F I aware operating system, which allows for the simultaneous testing of these functionalities.In scenarios where a driver operates without direct storage medium access, such as a network driver, testing becomes more nuanced. For instance, a network driver might expose a "ping" command functionality. Testing this would involve verifying the network controller's ability to send and receive data, a process that is critical for network communication. The text suggests that for such cases, a Preboot Execution Environment, or P X E, boot test would be a highly effective evaluation method. When evaluating drivers for a bus rather than a specific device, the testing strategy shifts. These drivers often necessitate the creation of child controllers and the utilization of intermediate I O protocols. Consequently, commands like DevTree are employed to inspect these parent-child relationships, ensuring their correct establishment.The process of testing an application, even a complex application such as a shell itself, requires a systematic approach. The initial step involves ensuring the application functions correctly with a consistent amount of memory. The second aspect focuses on controlling the application's input and output. This is achieved through techniques like standard input redirection, often combined with script files to manage the output programmatically, thereby enabling automated verification. The shell command MemMap can display memory information about the platform, specifically the allocation of bytes for various data types, such as BootServiceData. The MemMap command is run, recording the data, before and after running an application or loading and unloading a driver, and then run again, and the end results are compared with the first run.The commands Connect, Disconnect, and Map are required for setup and configuration of drivers for devices that are disk drives. Many commands can be used for write, read, and verify on a disk drive. A simple version would be to echo a text file to the new drive and then use the Compare command to verify it. The document then transitions to discuss potential termination scenarios for a shell environment. These scenarios are broadly categorized based on the shell's final state, ranging from immediate exit to indefinite background operation. The described end-game scenarios include the shell itself exiting, the O S Loader taking control, the shell transitioning into a platform component, or evolving into a persistent runtime application. The simplest case involves a user-initiated exit command, which terminates the shell's current execution context and returns control to the preceding environment.This could be done so that the next application in the boot list is called, to un-nest from one instance of the shell to another, or to return control directly to the boot manager or setup screen. The next simplest of these is when the O S Loader application is run. At some point during the O S Loader application, the Exit Boot Services A P I is called, via the system table, causing the shell to end indirectly. In this case, all memory in the system not marked as Runtime is allowed to be overwritten, including the shell. The goal is that the O S will take over memory management and thus the boot service memory is no longer required. The next possible method is that a shell application, or U E F I application, is the end goal of the platform. This means there is no operating system at all and that the platform will forever, until powered off, just run the application.The best example of this scenario is how some Hewlett-Packard printers use an application to do all the work of handling print jobs, controlling the queue, monitoring ink, and so on. This embedded platform has no operating system whatsoever. All it has is an application that runs forever. The most complex is somewhat of a hybrid of the previous two types. This is an application that handles everything like the preceding example, but uses the Exit Boot Services A P I as in the second example. This does allow the application to directly access hardware, but it also requires that this new application have drivers to handle this interaction. This distinction between this type of application and a true operating system may be more in the mind of the creator than anything else. It could be easily used for a hardware test where the boot time drivers need to stop interacting with the hardware, but where there is no real replacement of the features provided by an operating system.
