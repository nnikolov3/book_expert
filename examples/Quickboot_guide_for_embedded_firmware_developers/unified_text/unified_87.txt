The process of C P U initialization involves several critical steps, including configuring the processor and its associated machine registers, loading a microcode update, and enabling the Local A P I C. Microcode itself represents a hardware layer of instructions that is integral to the machine-defined architecture, and it is most commonly observed in C I S C-based processors. This microcode is developed by the C P U vendor and is typically incorporated into an internal C P U R O M during the manufacturing phase. However, due to historical issues such as the "Pentium flaw," Intel processor architecture allows microcode to be updated in the field, either through a B I O S update or an operating system update designated as "configuration data."Modern Intel processors necessitate the latest microcode update to function correctly. Intel provides microcode updates that are written to a specific writable microcode store within the C P U. These updates are encrypted and digitally signed by Intel, ensuring that only the processor for which the microcode was designed can authenticate and load it. In socketed systems, the B I O S may contain various flavors of microcode updates tailored to different processor steppings. It is crucial to load these microcode updates early in the boot sequence to minimize the exposure of the system to any known errata present in the silicon hardware. Additionally, microcode may need to be reapplied to the C P U after specific reset events occurring during the boot sequence. The Boot Strap Processor, or B S P, microcode update must be loaded before the system enters what is termed "No Eviction mode."The Local A P I C, which stands for Local Advanced Programmable Interrupt Controller, must be enabled to handle any interrupts that occur early in the power-on self-test, or P O S T, phase, and prior to enabling protected mode. For more detailed information pertaining to the Intel A P I C architecture and Local A P I Cs, reference is made to the Intel sixty-four and I A thirty-two Intel Architecture Software Developer's Manual, specifically Volume three A, covering System Programming.Before the processor can be switched to protected mode, the software initialization code must load a minimum number of protected mode data structures and code modules into memory to support reliable operation of the processor in protected mode. These data structures include an Interrupt Descriptor Table, or I D T, a Global Descriptor Table, or G D T, a Task State Segment, or T S S, and optionally, a Local Descriptor Table, or L D T. If the system employs paging for memory management, the initialization process must also prepare a page directory and at least one page table. The code also mandates the presence of a code segment containing the executable instructions that will run when the processor is in protected mode, as well as one or more code modules to manage interrupts and exceptions.Beyond these data structures, the initialization code must configure specific system registers, including the Global Descriptor Table Register, or G D T R, and optionally, the I D T R. The G D T R must be loaded with the base address and limit of the G D T, while the I D T R can be initialized either before or after switching to protected mode, but before enabling interrupts. Control registers C R one through C R four and the memory type range registers, or M T R R S, also play a crucial role in this process. With these data structures, code modules, and system registers initialized, the processor can be switched to protected mode by loading control register C R zero with a value that sets the P E flag, bit zero.Once in protected mode, the system is unlikely to enter sixteen-bit Real mode again until the next hardware reset, with the exception of Legacy Option ROMs and Legacy O S or B I O S interfaces. Detailed information about protected mode and real mode switching can be found in the Intel sixty-four and I A thirty-two Intel Architecture Software Developer's Manual, Volume three A, System Programming Guide, Chapter nine.In the early stages of booting, when no D R A M is available, the code operates in a stackless environment. Most modern processors have an internal cache that can be configured as R A M, or Cache as R A M, to provide a software stack. However, developers must write extremely tight code when using C A R because an eviction would be paradoxical to the system at this point in the boot sequence, as there is no memory to maintain coherency with. A special mode, known as "no evict mode" or N E M, allows the processor to operate in cache as R A M without causing evictions on cache line misses. Developing code with an available software stack is much easier, and initialization code often performs the minimal setup to use a stack even prior to D R A M initialization.Finally, the processor may boot into a slower mode than it is capable of performing, either due to risk considerations or power-saving measures. In such cases, it is necessary for the B I O S to initialize the speed step technology to ensure the processor operates at its intended speed. This involves configuring control registers and other system parameters to optimize performance while maintaining stability and security. By carefully managing these aspects of C P U initialization, the system can ensure a reliable and efficient boot process, laying the foundation for stable operation in protected mode.
