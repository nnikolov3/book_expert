The process of loading an operating system involves several steps and interfaces, particularly for Intel architecture devices. There are two primary operating system interfaces to consider: E F I, which stands for Extensible Firmware Interface, and legacy O S, which refers to older operating system architectures. For major operating systems like Microsoft and Linux, there are various second-stage boot loaders available for each interface. Additionally, Real-Time Operating Systems, or R T O S, and other proprietary operating systems may support either E F I, legacy, or both, or they may not support any of these interfaces.A third option exists, known as the null option, where there is no interface at all. In this scenario, the B I O S, or Basic Input/Output System, simply loads a specific address from a piece of Non-Volatile Random Access Memory, or N V R A M, and jumps to it, without the operating system looking back. This process is often referred to as a blind handoff.To understand how the system gets to the desired disk, it's essential to examine the Boot Device Selection phase theory of operation. This phase is also known as the boot services in other B I O S implementations. The boot services play a crucial role in selecting the boot device and loading the operating system. The process involves several steps, including the identification of available boot devices, the selection of the desired device, and the loading of the operating system from that device.In the context of system startup, a shell provides a convenient environment for executing applications and scripts, offering direct access to hardware functionalities. New U E F I shell interfaces and scripts provide a cost-effective and adaptable solution for various tasks, including system diagnostics, manufacturing processes, and enabling simple user applications. The U E F I shell's foundational elements are downloadable as open-source resources, and these capabilities can be readily integrated on top of the U E F I firmware.The U E F I standard represents a significant advancement over legacy B I O S systems, providing a more structured and extensible environment for system initialization and boot processes. The ability to run applications and scripts directly from the U E F I shell offers powerful capabilities for system recovery, configuration, and testing, bypassing the need for a fully installed operating system in many scenarios.When an application is executed within the U E F I environment, there are several possible models for its execution. The simplest model involves an application that directly returns control to the caller, which could be a shell or another application instance. A more specific scenario arises when the Operating System Loader invokes an ExitBootServices A P I, signaling the end of the boot services phase and allowing the Operating System to assume control over memory management.A further evolution in this interaction is an application that functions as the ultimate goal of the platform, persisting indefinitely or until a power cycle. This type of application can be found in certain embedded systems, such as Hewlett-Packard printers, where an embedded application manages all print job handling, queue monitoring, and ink status without requiring a conventional Operating System.The most sophisticated model described is a hybrid approach, combining elements of the previous two. This type of application handles extensive tasks, interacts directly with hardware, and necessitates the provision of drivers to manage these hardware interactions. This distinction highlights a design pattern where a highly capable application supersedes the typical Operating System role, or at least its initial boot stages, for specific functionalities. Such systems might be conceived for hardware testing or situations where a full Operating System is not required or is deliberately omitted, with the application providing all necessary operational features.
