The distribution of firmware images, specifically the E F I Shell, involves considerations of customization and overhead. The E F I Shell is provided in binary form, accessible via S V N repositories such as the E D K and E D K two standard distributions, with download locations specified. These distributions come in different sizes, where a larger image typically offers more command functionality. The binary E F I Shell is also distributed via S V N in the E D K two and U D K releases, with source code available for the E F I Shell subproject at a given Uniform Resource Locator. This source code includes build files that support distinct versions of the shell. Further, the source code for the U E F I Shell in the U D K distributions is also accessible via S V N, with customization managed through Platform Configuration Database entries and configured within the D S C files essential for building the shell.Regarding G U I s and the U E F I Shell, there is no direct, inherent support for graphical user interfaces within the shells themselves. However, the human interface infrastructure, or H I I, provides methods that can be leveraged for configuring and displaying localized content. This functionality can be accessed through the H I I Lib, which resides within the U D K E D K two environment, or directly through the H I I protocols as detailed in specific sections of the U E F I specification. An alternative approach to achieving similar functionality involves utilizing C libraries, enabling the compilation and use of standard graphics libraries directly within the shell. Moreover, companies have developed application development environments, some of which are commercially available, while others are intended for internal use only. An example of a publicly available solution is the A M I Provisioning solution.The U E F I Shell environment also supports remote control, which is a crucial aspect of debugging and testing. Both the E F I and U E F I Shells are remote controllable since all E F I implementations have support for remote control over the serial port of the keyboard and console. This is not a modern over-the-internet remote desktop style of control, but it is certainly sufficient. Remote control of a system running a shell requires a second computer to be the host for the testing. A very common technique for remote debugging a platform involves connecting both a hardware debugger and a serial port between a host and the platform-under-development, or P U D. Then the engineer doing the debugging remotely, via the modern remote desktop connection of their choice, controls the host computer and then controls the P U D via the hardware debugger and the serial connection. The biggest challenge in this scenario is changing the copy of an application the P U D has access to. Utilizing K V Ms with built-in U S B switching capability, in conjunction with a standard U S B drive, allows for the U E F I application under debug to be updated without requiring physical manipulation.Driver and application debugging is an excellent use of shells, with many commands explicitly designed to enable and assist in this process. In the U E F I Shell, these commands are contained in the "Drivers one" and "Debug one" profiles, while in the E F I Shell, they are found in the Full image. The basic parts of a driver that can be tested depend on the type of driver. For a driver with a storage medium present, verification can be performed to ensure the driver installed the correct protocols, that the platform built the upper parts of the driver stack, and that writing and reading to or from the storage medium are functioning correctly. Additionally, it can be verified that the driver frees all allocated memory upon unloading. For drivers without a storage medium, such as network drivers, testing may be more limited, but the "Network one" profile's ping command can verify data sending and receiving capabilities. The best test for network drivers would be a P X E boot test. When testing bus drivers, it is essential to verify the creation of child controllers and intermediate I O protocols, using commands like DevTree, Devices, and Drivers to confirm the correct establishment of parent-child relationships.Testing an application, even a complex one like the shell itself, requires significant effort. An application should, upon completion, leave the system with the same amount of memory as when it started. Testing can utilize StdIn redirection to control input and StdOut redirection, combined with script files, to automatically verify output. This comprehensive approach to debugging and testing within the U E F I Shell environment underscores the importance of meticulous verification and validation in ensuring the reliability and functionality of drivers and applications.
