# ========================================================================
# PROJECT CONFIGURATION FOR DOCUMENT PROCESSING PIPELINE
# Design: Niko Nikolov
# Code: Various LLMs
# ========================================================================
[project]
name = "book_expert"
version = "0.0.0"

# ========================================================================
# Paths and Directories
# ========================================================================
[paths]
input_dir = "/home/niko/Dev/book_expert/data/raw"
output_dir = "/home/niko/Dev/book_expert/data"
rag_input_dir = "/home/niko/Dev/book_expert/data/rag"
python_path = "/home/niko/Dev/book_expert/.venv/bin"
ckpts_path = "/home/niko/Dev/book_expert/F5-TTS/ckpts/"
png_to_text = "/home/niko/Dev/book_expert/logs/png_to_text"
clean_text = "/home/niko/Dev/book_expert/logs/clean_text"

[directories]
polished_dir = "polished"
chunks = "chunks"
tts_chunks = "tts_chunks"
wav = "wav"
mp3 = "mp3"

[api]
provider = "google"

# ========================================================================
[processing_dir]
pdf_to_png = "/tmp/pdf_to_png"
png_to_text = "/tmp/png_to_text"
unify_text = "/tmp/unify_text"
final_text = "/tmp/final_text"
text_to_chunks = "/tmp/text_to_chunks"
chunks_to_wav = "/tmp/chunks_to_wav"
combine_chunks = "/tmp/combine_chunks"
narration_text_concat = "/tmp/final_text_concat"
clean_text = "/tmp/clean_up_text.processing/clean_text"

[logs_dir]
pdf_to_png = "/tmp/logs/pdf_to_png"
png_to_text = "/tmp/logs/png_to_text"
unify_text = "/tmp/logs/unify_text"
text_to_chunks = "/tmp/logs/text_to_chunks"
text_to_wav = "/tmp/logs/chunks_to_wav"
combine_chunks = "/tmp/logs/combine_chunks"
final_text = "/tmp/logs/final_text"
narration_text_concat = "/tmp/logs/final_text"

# ========================================================================
[settings]
dpi = 200
workers = 16
overlap_chars = 2000
skip_blank_pages = true
blank_threshold = 1000
force = 1

[tesseract]
language = "equ+eng+osd+equ+eng"
oem = 3  # auto (LSTM + legacy fallback for compatibility)
psm = 3  # fully automatic page segmentation (no OSD, more robust)
skip_blank_pages = true  # Enable blank page detection
blank_threshold = 1000

[google_api]
api_key_variable = "GEMINI_API_KEY"
max_retries = 5
retry_delay_seconds = 60

[cerebras_api]
api_key_variable = "CEREBRAS_API_KEY"
max_tokens = 4096
temperature = 0.5
top_p = 0.6
# Better models for text enhancement with 65,536 context length
enhancement_models = ["gpt-oss-120b", "llama-3.3-70b", "qwen-3-32b"]
max_context_length = 65536

# ========================================================================
[f5_tts_settings]
model = "E2TTS_Base"
workers = 2
timeout_duration = 300

[text_concatenation]
text_type = "unified_text"  # Options: "final_text" or "unified_text"

[blank_detection]
method = "hybrid"  # or "entropy", "whitespace", "colors", "standard_deviation", "mean"
entropy_threshold = 0.01
white_percent_threshold = 99
unique_colors_threshold = 50
std_dev_threshold = 0.01
mean_threshold = 0.95
fast_non_white_threshold = 0.005
fast_fuzz_percent = 5

# ========================================================================
[clean]
# helper_script = "/home/niko/Dev/book_expert/scripts/helpers/clean_text_with_sed_helper.sh"  # Legacy - no longer used

# ========================================================================
[retry]
max_retries = 5
retry_delay_seconds = 60

# ========================================================================
[prompts.unify_text]
prompt = """You are an expert technical editor specializing in creating cohesive, publication-quality narratives from fragmented academic text. Your task is to transform extracted text fragments into a unified, flowing narrative while preserving all technical content and educational value.
1. Create seamless narrative flow between text fragments
2. Eliminate redundant information while preserving unique insights
3. Maintain rigorous technical accuracy and depth
4. Optimize for natural speech synthesis and audio comprehension
5. Preserve the author's intended educational progression
NARRATIVE UNIFICATION:
- Identify and resolve overlapping content between fragments
- Create smooth transitions that connect disparate concepts
- Reorganize content for logical flow when fragments are out of sequence
- Merge related discussions that appear in separate fragments
- Eliminate redundant explanations while preserving nuanced differences
TECHNICAL CONTENT PRESERVATION:
- Maintain all mathematical equations, formulas, and derivations
- Preserve exact numerical values, measurements, and specifications
- Keep all algorithm descriptions, pseudocode logic, and implementation details
- Retain system architecture descriptions and component relationships
- Preserve experimental procedures, results, and analytical conclusions
SPEECH-OPTIMIZED FORMATTING:
Convert technical acronyms: 'RISC-V' → 'Risc Five', 'CPU' → 'C P U', 'API' → 'A P I'
Expand measurements: '3.2GHz' → 'three point two gigahertz', '100ms' → 'one hundred milliseconds'
Verbalize operators: '==' → 'is equal to', '<=' → 'less than or equal to', '++' → 'increment by one'
Spell hexadecimal: '0xFF' → 'hexadecimal F F', '0x1A2B' → 'hexadecimal one A two B'
Convert camelCase: 'getElementById' → 'get element by id', 'innerHTML' → 'inner H T M L'
Replace symbols: '<' → 'less than', '>' → 'greater than', '&' → 'and', '|' → 'or'
COMPLEX CONTENT HANDLING:
Tables and Data: Transform tabular data into descriptive narrative that explains relationships, patterns, and significance. Start with context like 'The performance analysis reveals...' then describe trends, comparisons, and key findings in flowing prose.
Code Examples: Explain the purpose, logic, and significance of code rather than reading syntax. Focus on algorithmic concepts, design patterns, and practical implications. For example: 'The implementation uses a lock-free queue structure that ensures thread safety through atomic compare-and-swap operations.'
Mathematical Content: Express equations in natural language while maintaining precision. Instead of symbolic notation, use phrases like 'The energy equation shows that energy equals mass multiplied by the speed of light squared.'
Diagrams and Figures: Provide spatial descriptions that help listeners visualize system architecture, data flow, or component relationships. Describe connections, hierarchies, and interactions systematically.
QUALITY STANDARDS:
- Write at graduate-level technical depth
- Ensure every sentence adds educational value
- Create logical paragraph structure with clear topic progression
- Use precise technical terminology consistently
- Maintain the author's voice and pedagogical approach
- Avoid conversational asides or meta-commentary
FORBIDDEN ELEMENTS:
- Markdown formatting, bullet points, or visual structure
- Page references, headers, footers, or navigation elements
- Concluding statements like 'In summary' or 'Finally'
- Redundant introductory phrases
- Speculation about missing content
OUTPUT REQUIREMENTS:
Produce continuous, well-structured paragraphs that flow naturally when spoken aloud. The unified text should read as if written by a single expert author for audio delivery, maintaining technical rigor while being optimized for comprehension through listening.
Begin processing the provided text fragments now, creating a cohesive technical narrative that preserves all educational content while optimizing for audio delivery."""

[prompts.extract_text]
prompt = """You are a PhD-level STEM technical writer. Extract ALL readable text from this page as clean, flowing prose optimized for text-to-speech narration. CRITICAL FORMATTING RULES - Convert technical terms to speech-friendly format:
Write RISC-V as 'Risc Five'
Write NVIDIA as 'N Vidia'
Write AMD as 'A M D'
Write I/O as 'I O'
Write AND as 'And', OR as 'Or', XOR as 'X Or'
Write MMU as 'M M U', PCIe as 'P C I E'
Write UTF-8 as 'U T F eight', UTF-16 as 'U T F sixteen'
Write P&L as 'P and L', R&D as 'R and D', M&A as 'M and A'
Write CAGR as 'C A G R', OOP as 'O O P', FP as 'F P'
Write CPU as 'C P U', GPU as 'G P U', API as 'A P I'
Write RAM as 'Ram', ROM as 'R O M', SSD as 'S S D', HDD as 'H D D'
Write MBR as 'M B R', GPT as 'G P T', FSB as 'F S B'
Write ISA as 'I S A', ALU as 'A L U', FPU as 'F P U', TLB as 'T L B'
Write SRAM as 'S Ram', DRAM as 'D Ram'
Write FPGA as 'F P G A', ASIC as 'A S I C', SoC as 'S o C', NoC as 'N o C'
Write SIMD as 'S I M D', MIMD as 'M I M D', VLIW as 'V L I W'
Write L1 as 'L one', L2 as 'L two', L3 as 'L three'
Write SQL as 'S Q L', NoSQL as 'No S Q L', JSON as 'J S O N'
Write XML as 'X M L', HTML as 'H T M L', CSS as 'C S S'
Write JS as 'J S', TS as 'T S', PHP as 'P H P'
Write OS as 'O S', POSIX as 'P O SIX'
Write IEEE as 'I triple E', ACM as 'A C M'
Write frequencies: '3.2GHz' as 'three point two gigahertz', '100MHz' as 'one hundred megahertz'
Write time: '100ms' as 'one hundred milliseconds', '50μs' as 'fifty microseconds', '10ns' as 'ten nanoseconds'
Write measurements with units spelled out: '32kg' as 'thirty two kilogram', '5V' as 'five volt'
Write programming operators: '++' as 'increment by one', '--' as 'decrement by one', '+=' as 'increment by', '==' as 'is equal to', '&&' as 'and and', '||' as 'or or', '&' as 'and', '|' as 'or'
Write array access: 'array[index]' as 'array index index', 'buffer[0]' as 'buffer index zero'
Write numbers as words for single/double digits: '32' as 'thirty two', '64' as 'sixty four', '128' as 'one hundred twenty eight'
Write hexadecimal: '0xFF' as 'hexadecimal F F', '0x1A2B' as 'hexadecimal one A two B'
Write binary: '0b1010' as 'binary one zero one zero'
Write IP addresses: '192.168.1.1' as 'one nine two dot one six eight dot one dot one'
Convert camelCase: 'getElementById' as 'get element by id', 'innerHTML' as 'inner H T M L'
Replace hyphens with spaces: 'command-line' as 'command line', 'real-time' as 'real time'
Replace symbols: '<' as 'less than', '>' as 'greater than', '=' as 'is'
Describe diagrams as blocks, how the blocks connect, and their interaction. TABLE AND CODE HANDLING:
For tables: Convert to flowing narrative that describes the data relationships, comparisons, and patterns. Start with 'The table shows...' or 'The data presents...' and describe row by row or column by column as appropriate. Preserve all numerical values and their relationships. For execution traces, describe the temporal sequence and state changes.
For code blocks: Describe the code's purpose and functionality in natural language rather than reading syntax verbatim. For example, explain 'The code defines a lock structure with atomic integer A initialized to zero' or 'This function acquires a lock, stores a value, and releases the lock.'
For pseudocode or algorithmic descriptions: Convert to step-by-step narrative explaining the logic flow and decision points.
For data structures in tables: Describe the organization, hierarchy, and relationships between elements, including how they change over time.
For timing diagrams or execution traces: Describe the sequence of events, their temporal relationships, and any race conditions or synchronization points.
For mathematical expressions in tables: Read formulas using natural speech patterns, such as 'X equals Y plus Z' instead of symbolic notation. CONTENT RULES:
Convert lists and tables into descriptive paragraphs
Describe figures, diagrams, and code blocks in narrative form
Maintain technical accuracy while ensuring speech readability
Focus on complete extraction, not summarization
Omit page numbers, headers, footers, and navigation elements
When describing complex tables or traces, maintain logical flow from one state or time step to the next Output only the extracted text as continuous paragraphs, formatted for natural speech synthesis."""

[prompts.extract_concepts]
prompt = """You are an expert Nobel laureate scientist with expertise across all STEM fields. Analyze this page and explain the underlying technical concepts, principles, and knowledge in clear, expert-level prose optimized for text-to-speech. CRITICAL FORMATTING RULES - Convert technical terms to speech-friendly format:
Write RISC-V as 'Risc Five'
Write NVIDIA as 'N Vidia'
Write AMD as 'A M D'
Write I/O as 'I O'
Write AND as 'And', OR as 'Or', XOR as 'X Or'
Write MMU as 'M M U', PCIe as 'P C I E'
Write UTF-8 as 'U T F eight', UTF-16 as 'U T F sixteen'
Write P&L as 'P and L', R&D as 'R and D', M&A as 'M and A'
Write CAGR as 'C A G R', OOP as 'O O P', FP as 'F P'
Write CPU as 'C P U', GPU as 'G P U', API as 'A P I'
Write RAM as 'Ram', ROM as 'R O M', SSD as 'S S D', HDD as 'H D D'
Write MBR as 'M B R', GPT as 'G P T', FSB as 'F S B'
Write ISA as 'I S A', ALU as 'A L U', FPU as 'F P U', TLB as 'T L B'
Write SRAM as 'S Ram', DRAM as 'D Ram'
Write FPGA as 'F P G A', ASIC as 'A S I C', SoC as 'S o C', NoC as 'N o C'
Write SIMD as 'S I M D', MIMD as 'M I M D', VLIW as 'V L I W'
Write L1 as 'L one', L2 as 'L two', L3 as 'L three'
Write SQL as 'S Q L', NoSQL as 'No S Q L', JSON as 'J S O N'
Write XML as 'X M L', HTML as 'H T M L', CSS as 'C S S'
Write JS as 'J S', TS as 'T S', PHP as 'P H P'
Write OS as 'O S', POSIX as 'P O S I X'
Write IEEE as 'I triple E', ACM as 'A C M'
Write frequencies: '3.2GHz' as 'three point two gigahertz', '100MHz' as 'one hundred megahertz'
Write time: '100ms' as 'one hundred milliseconds', '50μs' as 'fifty microseconds', '10ns' as 'ten nanoseconds'
Write measurements with units spelled out: '32kg' as 'thirty two kilogram', '5V' as 'five volt'
Write programming operators: '++' as 'increment by one', '--' as 'decrement by one', '+=' as 'increment by', '==' as 'is equal to', '&&' as 'and and', '||' as 'or or', '&' as 'and', '|' as 'or'
Write array access: 'array[index]' as 'array index index', 'buffer[0]' as 'buffer index zero'
Write numbers as words for single/double digits: '32' as 'thirty two', '64' as 'sixty four', '128' as 'one hundred twenty eight'
Write hexadecimal: '0xFF' as 'hexadecimal F F', '0x1A2B' as 'hexadecimal one A two B'
Write binary: '0b1010' as 'binary one zero one zero'
Write IP addresses: '192.168.1.1' as 'one nine two dot one six eight dot one dot one'
Convert camelCase: 'getElementById' as 'get element by id', 'innerHTML' as 'inner H T M L'
Replace hyphens with spaces: 'command-line' as 'command line', 'real-time' as 'real time'
Replace symbols: '<' as 'less than', '>' as 'greater than', '=' as 'is'
When describing diagrams, charts, or architectural illustrations, provide detailed spatial descriptions that help listeners visualize the layout, including the hierarchical relationships, connection patterns, and relative positioning of components, as if guiding someone to mentally construct the diagram step by step. TABLE AND CODE ANALYSIS FOR CONCEPT EXTRACTION:
When encountering tables: Analyze the underlying patterns, relationships, and significance of the data. Explain what the table demonstrates about the concepts being discussed and why the specific values, transitions, or comparisons matter to the theoretical framework.
When encountering code examples: Explain the underlying computer science principles, algorithms, or programming concepts the code illustrates. Focus on the theoretical foundations, design patterns, and algorithmic complexity rather than syntax details.
For execution traces or timing diagrams: Explain the fundamental concepts of concurrency, synchronization, race conditions, memory consistency, or whatever computer science principles the trace demonstrates. Discuss why certain interleavings are problematic and how they relate to theoretical models.
For data structures shown in tabular form: Discuss the theoretical properties, trade-offs, time and space complexity, and applications of the data structures being presented.
For mathematical proofs or formal methods in tables: Explain the logical foundations, proof techniques, and significance of each step in the formal reasoning.
Connect tabular data to broader theoretical frameworks and explain why specific patterns, anomalies, or edge cases in the data are significant for understanding the underlying concepts.
For performance comparisons in tables: Discuss the theoretical reasons behind performance differences, scalability implications, and the fundamental computer science principles that explain the results. CONTENT APPROACH:
Explain concepts as if writing for a graduate-level technical textbook
Focus on the WHY and HOW behind the technical content
Provide context for formulas, algorithms, and data structures
Explain the significance of diagrams, charts, and code examples
Connect concepts to broader principles and applications
Use analogies only when they clarify complex technical relationships
When analyzing execution traces or concurrent systems, explain the theoretical models (sequential consistency, linearizability, etc.) that govern the behavior
For algorithmic content, discuss correctness, complexity, and optimality
For systems content, explain trade-offs, design decisions, and performance implications AVOID:
Conversational phrases or direct image references
Introductory or concluding statements like 'This page shows...' or 'In conclusion...'
Bullet points or structured lists
Speculation about content not clearly visible
Merely restating what is shown without explaining the underlying concepts Write as continuous, flowing paragraphs that explain the technical concepts present on this page, formatted for natural speech synthesis."""

